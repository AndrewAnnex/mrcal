#!/usr/bin/python2

r'''Renders a vector field to visualize the effect of a model

Synopsis:

  $ show-distortion --vectorfield left.cameramodel
  ... a plot pops up showing the distortion vector field

This allows us to visually see what a distortion model does. Depending on the
model, the vectors could be very large or very small, and we can scale them by
passing '--scale s'. By default we sample in a 60x40 grid, but this spacing can
be controlled by passing '--gridn w h'.

By default we render a heat map of the distortion. We can also see the
vectorfield by passing in --vectorfield. Or we can see the radial distortion
curve by passing --radial
'''


import numpy as np
import numpysane as nps
import gnuplotlib as gp
import sys
import re
import argparse
import os

import mrcal.cahvor
import mrcal



def parse_args():

    parser = \
        argparse.ArgumentParser(description = __doc__,
                                formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument('--gridn',
                        type=int,
                        default = (60,40),
                        nargs = 2,
                        help='''How densely we should sample the imager. By default we report a 60x40 grid''')

    parser.add_argument('--scale',
                        type=float,
                        default = 1.0,
                        help='''Scale the vectors by this factor. Default is 1.0 (report the truth), but this is often too small to see''')

    parser.add_argument('--radial',
                        action='store_true',
                        help='''Show the radial distortion scale factor instead of a colormap/vectorfield''')
    parser.add_argument('--vectorfield',
                        action = 'store_true',
                        default = False,
                        help='''Plot the diff as a vector field instead of as a heat map. The vector field
                        contains more information (magnitude AND direction), but
                        is less clear at a glance''')

    parser.add_argument('--cbmax',
                        type=float,
                        default=10,
                        help='''Maximum range of the colorbar''')

    parser.add_argument('--extratitle',
                        type=str,
                        default = None,
                        help='''Extra title string for the plot''')

    parser.add_argument('--hardcopy',
                        type=str,
                        help='''Write the output to disk, instead of making an interactive plot''')
    parser.add_argument('--extraset',
                        type=str,
                        action='append',
                        help='''Extra 'set' directives to gnuplot. Can be given multiple times''')

    parser.add_argument('model',
                        type=lambda f: f if os.path.isfile(f) else \
                                parser.error("The cameramodel must be an existing readable file, but got '{}'".format(f)),
                        nargs=1,
                        help='''Input camera model. Assumed to be mrcal native, unless the name is xxx.cahvor,
                        in which case the cahvor format is assumed''')

    return parser.parse_args()



args = parse_args()
model_filename = args.model[0]
if re.match(".*\.cahvor$", model_filename):
    model = mrcal.cahvor.read(model_filename)
else:
    model = mrcal.cameramodel(model_filename)

if args.radial and args.vectorfield:
    sys.stderr.write("Usage error: at most one of --radial and --vectorfield can be given\n")
    sys.exit(1)



# get the input and output grids of shape Nwidth,Nheight,2
W,H = model.imagersize()
intrinsics = model.intrinsics()

gridn_x,gridn_y = args.gridn

plotkwargs = {}
if args.extraset is not None:
    plotkwargs['set'] = args.extraset
if args.hardcopy is not None:
    plotkwargs['hardcopy'] = args.hardcopy

title = "Distortion of '{}' with {}".format(model_filename, intrinsics[0])
if args.extratitle is not None:
    title += ": " + args.extratitle
plotkwargs['title'] = title

if not args.vectorfield and not args.radial:
    # heat map

    if 'set' not in plotkwargs:
        plotkwargs['set'] = []
    elif type(plotkwargs['set']) is not list:
        plotkwargs['set'] = [plotkwargs['set']]
    plotkwargs['set'].extend(['xrange [:] noextend',
                              'yrange [:] noextend reverse',
                              'view equal xy',
                              'view map',
                              'contour surface',
                              'cntrparam levels incremental {},-1,0'.format(args.cbmax)])

    grid, dgrid = mrcal.distortion_map__to_warped(intrinsics,
                                                  np.linspace(0,W-1,gridn_x),
                                                  np.linspace(0,H-1,gridn_y))

    # shape: gridn_x*gridn_y,2
    delta = dgrid-grid
    delta *= args.scale

    # shape: gridn_y,gridn_x. Because numpy (and thus gnuplotlib) want it that
    # way
    distortion = nps.transpose(np.sqrt(nps.norm2(delta)))

    using='($1*{}):($2*{}):3'.format(float(W-1)/(gridn_x-1), float(H-1)/(gridn_y-1))
    # Currently "with image" can't produce contours. I work around this, by
    # plotting the data a second time.
    # Yuck.
    # https://sourceforge.net/p/gnuplot/mailman/message/36371128/
    gp.plot((distortion, dict(               tuplesize=3, _with='image',           using=using)),
            (distortion, dict(legend="diff", tuplesize=3, _with='lines nosurface', using=using)),
            _3d=1,
            unset='grid',
            _xrange=[0,W],
            _yrange=[H,0],
            cbrange=[0,args.cbmax],
            ascii=1,
            **plotkwargs)

elif args.vectorfield:

    grid, dgrid = mrcal.distortion_map__to_warped(intrinsics,
                                                  np.linspace(0,W-1,gridn_x),
                                                  np.linspace(0,H-1,gridn_y))

    # shape: gridn*gridn,2
    grid  = nps.clump(grid,  n=2)
    dgrid = nps.clump(dgrid, n=2)

    delta = dgrid-grid
    delta *= args.scale

    plotkwargs['_xrange']=(-50,W+50)
    plotkwargs['_yrange']=(H+50, -50)
    plotkwargs['_set'   ]=['object 1 rectangle from 0,0 to {},{} fillstyle empty'.format(W,H)]
    plotkwargs['square' ]=True

    if 'set' in plotkwargs:
        if type(plotkwargs['set']) is list: plotkwargs['_set'].extend(plotkwargs['set'])
        else:                               plotkwargs['_set'].append(plotkwargs['set'])
        del plotkwargs['set']

    gp.plot( (grid[:,0], grid[:,1], delta[:,0], delta[:,1],
              {'with': 'vectors size screen 0.005,10 fixed filled',
               'tuplesize': 4,
               }),
             (grid[:,0], grid[:,1],
              {'with': 'points',
               'tuplesize': 2,
               }),
             **plotkwargs )

else:

    # plot the radial distortion. For now I only deal with opencv here
    m = re.search("OPENCV([0-9]+)", intrinsics[0])
    if not m:
        raise Exception("Radial distortion visualization only implemented for OpenCV distortions for now")
    N = int(m.group(1))

    # OpenCV does this:
    #
    # This is the opencv distortion code in cvProjectPoints2 in calibration.cpp
    # Here x,y are x/z and y/z. OpenCV applies distortion to x/z, y/z and THEN
    # does the ...*f + c thing.
    #
    #         r2 = x*x + y*y;
    #         r4 = r2*r2;
    #         r6 = r4*r2;
    #         a1 = 2*x*y;
    #         a2 = r2 + 2*x*x;
    #         a3 = r2 + 2*y*y;
    #         cdist = 1 + k[0]*r2 + k[1]*r4 + k[4]*r6;
    #         icdist2 = 1./(1 + k[5]*r2 + k[6]*r4 + k[7]*r6);
    #         xd0 = x*cdist*icdist2 + k[2]*a1 + k[3]*a2 + k[8]*r2+k[9]*r4;
    #         yd0 = y*cdist*icdist2 + k[2]*a3 + k[3]*a1 + k[10]*r2+k[11]*r4;

    # mean focal length
    f = (intrinsics[1][0] + intrinsics[1][1]) / 2.
    xc = intrinsics[1][2]
    yc = intrinsics[1][3]

    distortions = intrinsics[1][4:]
    k2 = distortions[0]
    k4 = distortions[1]
    k6 = 0
    if N >= 5:
        k6 = distortions[4]
    numerator = '1. + xs*xs * ({} + xs*xs * ({} + xs*xs * {}))'.format(k2,k4,k6)
    numerator = numerator.replace('xs', 'x/{}'.format(f))

    if N >= 8:
        denominator = '1. + xs*xs * ({} + xs*xs * ({} + xs*xs * {}))'.format(*distortions[5:8])
        denominator = denominator.replace('xs', 'x/{}'.format(f))
        scale = '({})/({})'.format(numerator,denominator)
    else:
        scale = numerator


    x01     = np.array((xc, W-xc), dtype=float)
    y01     = np.array((yc, H-yc), dtype=float)
    corners = nps.transpose( nps.glue( nps.cat(x01, y01),
                                       nps.cat(x01, y01[::-1]),
                                       axis=-1))
    corners_len = np.sqrt(nps.norm2(corners))

    equations = ['x * ({}) with lines title "distorted"'.format(scale),
                 'x title "undistorted"']
    sets=['arrow from {xy}, graph 0 to {xy}, graph 1 nohead lc "red"'  .format(xy = x01[0]),
          'arrow from {xy}, graph 0 to {xy}, graph 1 nohead lc "red"'  .format(xy = x01[1]),
          'arrow from {xy}, graph 0 to {xy}, graph 1 nohead lc "green"'.format(xy = y01[0]),
          'arrow from {xy}, graph 0 to {xy}, graph 1 nohead lc "green"'.format(xy = y01[1]),
          'arrow from {xy}, graph 0 to {xy}, graph 1 nohead lc "blue"' .format(xy = corners_len[0]),
          'arrow from {xy}, graph 0 to {xy}, graph 1 nohead lc "blue"' .format(xy = corners_len[1]),
          'arrow from {xy}, graph 0 to {xy}, graph 1 nohead lc "blue"' .format(xy = corners_len[2]),
          'arrow from {xy}, graph 0 to {xy}, graph 1 nohead lc "blue"' .format(xy = corners_len[3])]
    if 'set' in plotkwargs:
        if type(plotkwargs['set']) is list: sets.extend(plotkwargs['set'])
        else:                               sets.append(plotkwargs['set'])
        del plotkwargs['set']
    if '_set' in plotkwargs:
        if type(plotkwargs['set']) is list: sets.extend(plotkwargs['_set'])
        else:                               sets.append(plotkwargs['_set'])
        del plotkwargs['_set']

    if N >= 8:
        equations.append(numerator   + ' axis x1y2 title "numerator (y2)"')
        equations.append(denominator + ' axis x1y2 title "denominator (y2)"')
        sets.append('y2tics')
    plotkwargs['title'] += ': radial distortion. Red: x edges. Green: y edges. Blue: corners'
    gp.plot(equation = equations,
            _set=sets,
            _xrange = [0,np.max(corners_len) * 1.05],
            xlabel = 'Pixels from the projection center',
            ylabel = 'Pixels',
            **plotkwargs)

if args.hardcopy is None:
    gp.wait()
