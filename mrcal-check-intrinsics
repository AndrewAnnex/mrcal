#!/usr/bin/python3


r'''Converts a camera model from one distortion model to another

SYNOPSIS

  $ mrcal-check-intrinsics
      --viz --to DISTORTION_OPENCV4 left.cameramodel
      > left.opencv4.cameramodel

  ... lots of output as the solve runs ...
  libdogleg at dogleg.c:1064: success! took 10 iterations
  RMS error of the solution: 3.40256580058 pixels.

  ... a plot pops up showing the vector field of the difference ...


DESCRIPTION

Takes a model and a single chessboard observation. Fits that observation to

the model, and reports the fit. If the intrinsics line up, we'll see a good fit.



This is a tool to convert a given camera model from one distortion model to
another. The input and output models have identical extrinsics and an identical
intrinsic core (focal lengths, center pixel coords). The ONLY differing part is
the distortion coefficients.

While the distortion models all exist to solve the same problem, the different
representations don't map to one another perfectly, so this tool seeks to find
the best fit only. It does this by sampling a number of points in the imager,
converting them to observation vectors in the camera coordinate system (using
the given camera model), and then fitting a new camera model (with a different
distortions) that matches the observation vectors to the source imager
coordinates.

Note that the distortion model implementations are usually optimized in the
'undistort' direction, not the 'distort' direction, so the step of converting
the target imager coordinates to observation vectors can be slow. This is highly
dependent on the camera model specifically. CAHVORE especially is glacial. This
can be mitigated somewhat by a better implementation, but in the meantime,
please be patient.

Camera models have originally been computed by a calibration procedure that
takes as input a number of point observations, and the resulting models are only
valid in an area where those observations were available; it's an extrapolation
everywhere else. This is generally OK, and we try to cover the whole imager when
calibrating cameras. Models with high distortions (CAHVORE, OPENCV >= 8)
generally have quickly-increasing effects towards the edges of the imager, and
the distortions represented by these models at the extreme edges of the imager
are often not reliable, since the initial calibration data is rarely available
at the extreme edges. Thus using points at the extreme edges to fit another
model is often counterproductive, and I provide the --where and --radius
commandline options for this case. We use data in a circular region of the
imager. This region is centered on the point given by --where (or at the center
of the imager, if omitted). The radius of this region is given by --radius. If
'--radius 0' is given, I use ALL the data. A radius<0 can be used to set the
size of the no-data margin at the corners; in this case I'll use sqrt(width^2 +
height^2) - abs(radius)

'''


from __future__ import print_function

import sys
import argparse
import re
import os

def parse_args():

    parser = \
        argparse.ArgumentParser(description = __doc__,
                                formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('--model',
                        type=lambda f: f if os.path.isfile(f) else \
                                parser.error("The cameramodel must be an existing readable file, but got '{}'".format(f)),
                        required=True,
                        help='''Input camera model.''')
    parser.add_argument('--object-width-n',
                        type=int,
                        default=10,
                        help='How many points the calibration board has per side')
    parser.add_argument('--corners-cache',
                        type=lambda f: f if os.path.isfile(f) or not os.path.isdir(f) else \
                                parser.error("--corners-cache requires an existing, readable file as the arg or a non-existing path, but got '{}'".format(f)),
                        required=False,
                        help='Path to read corner-finder data from or (if path does not exist) to write data to')
    parser.add_argument('image',
                        type=lambda f: f if os.path.isfile(f) else \
                                parser.error("The image must be a readable files, but got '{}'".format(f)),
                        help='''Chessboard image to evaluate''')
    return parser.parse_args()

args = parse_args()

# arg-parsing is done before the imports so that --help works without building
# stuff, so that I can generate the manpages and README





import numpy as np
import numpysane as nps
import cv2

import mrcal


m = mrcal.cameramodel(args.model)

observations, indices_frame_camera,_ = \
    mrcal.get_chessboard_observations(args.object_width_n,
                                      args.object_width_n,
                                      (args.image,),
                                      args.corners_cache)

Rt_frame = mrcal.estimate_local_calobject_poses( indices_frame_camera,
                                                 observations,
                                                 0.1, # dot spacing; irrelevant
                                                 args.object_width_n,
                                                 models_or_intrinsics = (m,) )

stats = mrcal.optimize(nps.dummy(m.intrinsics()[1], 0),
                       np.zeros((0,6)), # one camera; no extrinsics
                       mrcal.rt_from_Rt(Rt_frame),
                       None, # no points
                       observations,
                       indices_frame_camera,
                       None, None, # no points
                       m.intrinsics()[0],
                       nps.dummy(m.imagersize(), 0),

                       calibration_object_width_n        = args.object_width_n,
                       calibration_object_spacing        = 0.1, # irrelevant
                       do_optimize_intrinsic_core        = False,
                       do_optimize_intrinsic_distortions = False,

                       observed_pixel_uncertainty = 1.0,
                       skip_outlier_rejection = True,

                       VERBOSE = False)

xy = stats['x'].reshape(args.object_width_n*args.object_width_n, 2)
rms = np.sqrt(np.mean(nps.norm2(xy)))

print("RMS error: {}".format(rms))

r'''
Do visualization so that I can see the chessboard errors!!!!
'''
