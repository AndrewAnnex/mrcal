#!/usr/bin/python3

r'''Remaps a captured image into another camera model

SYNOPSIS

  $ mrcal-redistort-image
      camera0.cameramodel camera1.cameramodel
      image0.png image1.png
  Wrote image0-undistorted-remapped.png
  Wrote image1-undistorted.png

This tool takes an image of a scene captured by one camera model, and generates
an image of the same scene, as it would appear if captured by a different
model, taking into account both the different lens parameters and geometries.
This is similar to mrcal-reproject-points, but acts on a full image, rather
than a discrete set of points.

We have 3 modes of operation, selected with --mode:

- 'distortion' projects the same scene, only changing the distortion parameters
  from one camera to another. This ignores all extrinsics, from both cameras

- 'infinity' projects the same scene, applying the different distortion
  parameters and relative rotation between the two cameras. This ignores the
  translation components of the extrinsics. If the intrinsics and the rotation
  were correct, infinitely-far-away objects in the remapped camera0 image appear
  in the same exact location as the same objects in the camera1 image. This is
  thus a good validation function. This is the default mode.

- 'plane' maps observations of a given plane in camera0 coordinates to where
  this plane would be observed in camera1 coordinates. This uses ALL the
  intrinsics, extrinsics and the plane representation. If all of these are
  correct, the observations of this plane would line up exactly in the
  remapped-camera0 image and the camera1 image. The plane is represented in
  camera0 coordinates by a normal vector given by --plane-n, and the distance to
  the normal given by plane-d. The plane is all points p such that
  inner(p,planen) = planed. planen does not need to be normalized.

One way in which this is useful is using the 'infinity' mode for validation of
the rotation and the intrinsics: if these are correct, then observations of
infinitely-far-away objects in the remapped image would match the observations
made by the second camera.

The tool takes in the two camera models, the image from the first camera, and
optionally, the image from the second camera as well. If the second image is
omitted, the first image is remapped into the second camera's coordinates, and
this remapped image can then be compared to the second image directly. This is
what is normally desired, but it requires an "undistort" remapping, which could
be very slow, computationally. As a workaround, you can pass in the second image
as well. Then both images will be remapped into a common undistorted coordinate
system. As before, these two remapped images can be compared, and their view of
infinitely-far-away objects will line up if the rotations and intrinsics are
correct.

The output image(s) are written into the same directory as the input image(s),
with annotations in the filename. This tool will refuse to overwrite any
existing files unless --force is given.

'''

from __future__ import print_function

import sys
import argparse
import re
import os

def parse_args():

    parser = \
        argparse.ArgumentParser(description = __doc__,
                                formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument('--force', '-f',
                        action='store_true',
                        default=False,
                        help='''By default I don't overwrite existing files. Pass --force to overwrite them
                        without complaint''')

    parser.add_argument('--fit',
                        type=str,
                        required=False,
                        help='''If IMAGE-TO is given, we undistort both images. This can be done with any set
                        of pinhole intrinsics. This argument allows us to select
                        how this is done. If given, we'll scale the focal length
                        of the pinhole model to fit some of the original image
                        into the output. This is one of "corners",
                        "centers-horizontal", "centers-vertical". If omitted, we
                        keep the focal lengths the same. If we KNOW the scaling
                        we want, that can be passed-in directly with
                        --scale-focal instead. ''')

    parser.add_argument('--scale-focal',
                        type=float,
                        help='''Used if IMAGE-TO is given: we'll scale the focal length of the pinhole models
                        by this factor. This is a "zoom" operation. If we don't
                        know the scaling, but wish to compute it based on
                        fitting some points, use --fit instead''')

    parser.add_argument('--scale-image',
                        type=float,
                        default=1.0,
                        help='''Used if IMAGE-TO is given: we'll scale the dimensions of the pinhole images
                        by this factor. By default the scale is 1.0, i.e. the
                        undistorted and distorted images have the same size.
                        This parameter changes the RESOLUTION of the output,
                        unlike --scale-focal, which ZOOMS the output''')

    parser.add_argument('--mode',
                        default='infinity',
                        choices=['distortion', 'infinity', 'plane'],
                        help='''Specifies the mode of operation. The 'distortion' mode only switches to a
                        different lens model, ignoring extrinsics. The
                        'infinity' mode switches to a different distortion
                        model, and applies the relative rotation: infinitely-far
                        away objects end up remapping to the same place, we
                        ignore translations. The 'plane' mode maps a plane
                        (specified by --plane-n and --plane-d) to the same
                        place; we use all intrinsics and extrinsics''')

    parser.add_argument('--plane-n',
                        type=float,
                        nargs=3,
                        help='''If "--mode plane" this specifies the normal vector to the plane, in
                        from-camera coordinates. The normal does not need to be
                        normalized; any scaling is compensated in planed. The
                        plane is all points p such that inner(p,planen) =
                        planed. Unused in any other mode''')
    parser.add_argument('--plane-d',
                        type=float,
                        help='''If "--mode plane" this specifies the distance-along-the-normal to the plane,
                        in from-camera coordinates. The plane is all points p
                        such that inner(p,planen) = planed. Unused in any other
                        mode''')

    parser.add_argument('model-from',
                        type=str,
                        help='''Camera model for the FROM image. Assumed to be mrcal native, Unless the name
                        is xxx.cahvor, in which case the cahvor format is
                        used.''')

    parser.add_argument('model-to',
                        type=str,
                        help='''Camera model for the TO image. Assumed to be mrcal native, Unless the name is
                        xxx.cahvor, in which case the cahvor format is
                        assumed''')

    parser.add_argument('image-from',
                        type=lambda f: f if os.path.isfile(f) else \
                                parser.error("The image-from must be a readable file, but got '{}'".format(f)),
                        help='''Image to undistort, remap, and redistort (unless IMAGE-TO is omitted)''')

    parser.add_argument('image-to',
                        nargs='?', # this argument is optional
                        type=lambda f: f if os.path.isfile(f) else \
                                parser.error("The image-to must be a readable file, but got '{}'".format(f)),
                        help='''By default I remap image0 into the distorted coordinates of image1. This is
                        very slow, so a much faster option is to undistort both
                        images. Pass the second image here to do that''')

    return parser.parse_args()

args = parse_args()

if getattr(args, 'image-to') is None:
    if args.fit         is not None or \
       args.scale_focal is not None or \
       args.scale_image is not None:
        sys.stderr.write("--fit, --scale-focal, --scale-image makes sense ONLY when both images are given.\n")
        sys.exit(1)
else:
    if args.fit         is not None and \
       args.scale_focal is not None:
        sys.stderr.write("--fit and --scale-focal are mutually exclusive\n")
        sys.exit(1)


if args.mode == 'plane':
    if (args.plane_n is None or args.plane_d is None):
        sys.stderr.write("'--mode plane' requires both --plane-n and --plane-d\n")
        sys.exit(1)
elif (args.plane_n is not None or args.plane_d is not None):
    sys.stderr.write("'--mode NOT plane' requires neither --plane-d nor --plane-d\n")
    sys.exit(1)

# arg-parsing is done before the imports so that --help works without building
# stuff, so that I can generate the manpages and README





import numpy as np
import numpysane as nps
import cv2

import mrcal

def target_image_filename(f,suffix):
    m = re.match("(.*)\.([a-z][a-z][a-z])$", f, flags=re.I)
    if not m:
        raise Exception("imagefile must end in .xxx where 'xxx' is some image extension. Instead got '{}'".format(f))

    f = "{}-{}.{}".format(m.group(1),suffix,m.group(2))
    if not args.force and os.path.isfile(f):
        sys.stderr.write("Target image '{}' already exists. Doing nothing, and giving up. Pass -f to overwrite.\n".format(f))
        sys.exit(1)
    return f


plane_n = None
plane_d = None
if args.plane_n is not None:
    plane_n = np.array(args.plane_n, dtype=float)
if args.plane_d is not None:
    plane_d = args.plane_d

if getattr(args, 'image-to') is None:
    image0_output_filename = target_image_filename(getattr(args, 'image-from'), 'remapped')

    image0_remapped = mrcal.redistort_image(
                                    getattr(args, 'model-from'),
                                    getattr(args, 'model-to'),
                                    getattr(args, 'image-from'),
                                    plane_n = plane_n,
                                    plane_d = plane_d,
                                    mode = args.mode)

    cv2.imwrite(image0_output_filename, image0_remapped)
    sys.stderr.write("Wrote {}\n".format(image0_output_filename))

else:

    if args.scale_image <= 1e-6:
        sys.stderr.write("--scale-image should be given a reasonable value > 0.\n")
        sys.exit(1)

    image0_output_filename = target_image_filename(getattr(args, 'image-from'), 'undistorted-remapped')
    image1_output_filename = target_image_filename(getattr(args, 'image-to'  ), 'undistorted')

    models = (mrcal.cameramodel(getattr(args, 'model-from')),
              mrcal.cameramodel(getattr(args, 'model-to')) )

    if args.fit is None:
        if args.scale_focal is None:
            scale_f_pinhole = (1.0, 1.0)
        else:
            scale_f_pinhole = (float(args.scale_focal),float(args.scale_focal))
    elif re.match("^(corners|centers-horizontal|centers-vertical)$", args.fit):
        scale_f_pinhole = [mrcal.compute_scale_f_pinhole_for_fit(m, args.fit,
                                                                 scale_imagersize_pinhole = args.scale_image) for m in models]
    else:
        sys.stderr.write("--fit must be one of ('corners','centers-horizontal','centers-vertical')\n")
        sys.exit(1)

    mapxy1,model_pinhole1 = \
        mrcal.undistort_image__compute_map(models[1],
                                           scale_f_pinhole           = scale_f_pinhole[1],
                                           scale_imagersize_pinhole  = args.scale_image)
    image1_undistorted = mrcal.undistort_image(models[1], getattr(args,'image-to'),
                                               mapxy = mapxy1)

    image0_remapped = mrcal.redistort_image( models[0], model_pinhole1,
                                             getattr(args, 'image-from'),
                                             plane_n = plane_n,
                                             plane_d = plane_d,
                                             mode    = args.mode)


    cv2.imwrite(image0_output_filename, image0_remapped)
    sys.stderr.write("Wrote {}\n".format(image0_output_filename))
    cv2.imwrite(image1_output_filename, image1_undistorted)
    sys.stderr.write("Wrote {}\n".format(image1_output_filename))
