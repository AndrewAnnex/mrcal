#!/usr/bin/python3

r'''Remaps a captured image into another camera model

SYNOPSIS

  $ mrcal-redistort-image
      camera0.cameramodel camera1.cameramodel
      image0.png image1.png
  Wrote image0-undistorted-remapped.png
  Wrote image1-undistorted.png

This tool takes an image of a scene captured by one camera model, and generates
an image of the same scene, as it would appear if captured by a different model.
This is similar to mrcal-redistort-points, but acts on a full image, rather than
a discrete set of points. The two sets of intrinsics are always used. The
translation component of the extrinsics is always ignored; the rotation is
ignored as well if --ignore-rotation.

One way in which this is useful is for validation of the rotation and the
intrinsics: if these are correct, then observations of infinitely-far-away
objects in the remapped image would match the observations made by the second
camera.

The tool takes in the two camera models, the image from the first camera, and
optionally, the image from the second camera as well. If the second image is
omitted, the first image is remapped into the second camera's coordinates, and
this remapped image can then be compared to the second image directly. This is
what is normally desired, but it requires an "undistort" remapping, which could
be very slow, computationally. As a workaround, you can pass in the second image
as well. Then both images will be remapped into a common undistorted coordinate
system. As before, these two remapped images can be compared, and their view of
infinitely-far-away objects will line up if the rotations and intrinsics are
correct.

The output image(s) are written into the same directory as the input image(s),
with annotations in the filename. This tool will refuse to overwrite any
existing files unless --force is given.

'''

from __future__ import print_function

import sys
import argparse
import re
import os

def parse_args():

    parser = \
        argparse.ArgumentParser(description = __doc__,
                                formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument('--ignore-rotation',
                        action='store_true',
                        help='''By default the relative camera rotation is used in the transformation. If we
                        want to use the intrinsics ONLY, pass --ignore-rotation''')

    parser.add_argument('--force', '-f',
                        action='store_true',
                        default=False,
                        help='''By default I don't overwrite existing files. Pass --force to overwrite them
                        without complaint''')

    parser.add_argument('--fit',
                        type=str,
                        required=False,
                        help='''If IMAGE-TO is given, we undistort both images. This can be done with any
                        set of pinhole intrinsics. This argument allows us to
                        select how this is done. If given, we'll scale the focal
                        length of the pinhole model to fit some of the original
                        image into the output. This is one of "corners",
                        "centers-horizontal", "centers-vertical". If omitted, we
                        keep the focal lengths the same''')

    parser.add_argument('model-from',
                        type=lambda f: f if os.path.isfile(f) else \
                                parser.error("The cameramodel must be an existing readable file, but got '{}'".format(f)),
                        help='''Camera model for the FROM image. Assumed to be mrcal native, Unless the name
                        is xxx.cahvor, in which case the cahvor format is
                        used.''')

    parser.add_argument('model-to',
                        type=lambda f: f if os.path.isfile(f) else \
                                parser.error("The cameramodel must be an existing readable file, but got '{}'".format(f)),
                        help='''Camera model for the TO image. Assumed to be mrcal native, Unless the name is
                        xxx.cahvor, in which case the cahvor format is
                        assumed''')

    parser.add_argument('image-from',
                        type=lambda f: f if os.path.isfile(f) else \
                                parser.error("The image-from must be a readable file, but got '{}'".format(f)),
                        help='''Image to undistort, remap (unless --ignore-rotation), and redistort (unless
                        IMAGE-TO is omitted)''')

    parser.add_argument('image-to',
                        nargs='?', # this argument is optional
                        type=lambda f: f if os.path.isfile(f) else \
                                parser.error("The image-to must be a readable file, but got '{}'".format(f)),
                        help='''By default I remap image0 into the distorted coordinates of image1. This is
                        very slow, so a much faster option is to undistort both
                        images. Pass the second image here to do that''')

    return parser.parse_args()

args = parse_args()

if args.fit is not None and getattr(args, 'image-to') is None:
    sys.stderr.write("--fit makes sense ONLY when both images are given.\n")
    sys.exit(1)

# arg-parsing is done before the imports so that --help works without building
# stuff, so that I can generate the manpages and README






import numpy as np
import numpysane as nps
import cv2

import mrcal

def target_image_filename(f,suffix):
    m = re.match("(.*)\.([a-z][a-z][a-z])$", f, flags=re.I)
    if not m:
        raise Exception("imagefile must end in .xxx where 'xxx' is some image extension. Instead got '{}'".format(f))

    f = "{}-{}.{}".format(m.group(1),suffix,m.group(2))
    if not args.force and os.path.isfile(f):
        sys.stderr.write("Target image '{}' already exists. Doing nothing, and giving up. Pass -f to overwrite.\n".format(f))
        sys.exit(1)
    return f

if getattr(args, 'image-to') is None:
    image0_output_filename = target_image_filename(getattr(args, 'image-from'), 'remapped')

    image0_remapped = mrcal.redistort_image(
                                    getattr(args, 'model-from'),
                                    getattr(args, 'model-to'),
                                    getattr(args, 'image-from'),
                                    ignore_rotation = args.ignore_rotation)

    cv2.imwrite(image0_output_filename, image0_remapped)
    sys.stderr.write("Wrote {}\n".format(image0_output_filename))

else:

    image0_output_filename = target_image_filename(getattr(args, 'image-from'), 'undistorted-remapped')
    image1_output_filename = target_image_filename(getattr(args, 'image-to'  ), 'undistorted')

    models = (mrcal.cameramodel(getattr(args, 'model-from')),
              mrcal.cameramodel(getattr(args, 'model-to')) )

    if args.fit is None:
        scale_f_pinhole = (1.0, 1.0)
    elif re.match("^(corners|centers-horizontal|centers-vertical)$", args.fit):
        scale_f_pinhole = [mrcal.compute_scale_f_pinhole_for_fit(m, args.fit) for m in models]
    else:
        sys.stderr.write("--fit must be one of ('corners','centers-horizontal','centers-vertical')\n")
        sys.exit(1)

    mapxy1,model_pinhole1 = \
        mrcal.undistort_image__compute_map(models[1],
                                           scale_f_pinhole = scale_f_pinhole[1])
    image1_undistorted = mrcal.undistort_image(models[1], getattr(args,'image-to'),
                                               mapxy = mapxy1)

    image0_remapped = mrcal.redistort_image( models[0], model_pinhole1,
                                             getattr(args, 'image-from'),
                                             ignore_rotation = args.ignore_rotation )

    cv2.imwrite(image0_output_filename, image0_remapped)
    sys.stderr.write("Wrote {}\n".format(image0_output_filename))
    cv2.imwrite(image1_output_filename, image1_undistorted)
    sys.stderr.write("Wrote {}\n".format(image1_output_filename))
