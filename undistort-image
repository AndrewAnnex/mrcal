#!/usr/bin/python2

r'''Un-distorts image(s)

Synopsis:

  $ undistort-image --model left.cameramodel im1.png im2.png
  ... corresponding pinhole mrcal-native model
  Wrote im1-undistorted.png
  Wrote im2-undistorted.png

Given a single camera model (cahvor or mrcal-native) and some number of images,
this tool un-distorts each image and writes the result to disk. For each image
named xxxx.yyy, the new image filename is xxxx-undistorted.yyy. This tool
refuses to overwrite anything, and will barf if a target file already exists. A
corresponding pinhole camera model is also generated, and written to stdout.

Note that currently the corresponding pinhole model uses the same focal length,
center pixel values as the original, but no distortions. Thus the undistorted
images might cut out chunks of the original, or leave empty borders on the
edges.

'''


import numpy as np
import numpysane as nps
import sys
import re
import cv2
import argparse
import os

import multiprocessing
import signal

import mrcal



def parse_args():

    parser = \
        argparse.ArgumentParser(description = __doc__,
                                formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('--model',
                        type=lambda f: f if os.path.isfile(f) else \
                                parser.error("The cameramodel must be an existing readable file, but got '{}'".format(f)),
                        required=True,
                        nargs=1,
                        help='''Input camera model. Assumed to be mrcal native, Unless the name is xxx.cahvor,
                        in which case the cahvor format is assumed''')

    parser.add_argument('--fit',
                        type=str,
                        required=False,
                        help='''If given, we'll scale the focal length of the pinhole model to fit some of
                        the original image into the output. This is one of
                        "corners", "centers-horizontal", "centers-vertical"''')

    parser.add_argument('--force', '-f',
                        action='store_true',
                        default=False,
                        help='''By default I don't overwrite existing files. Pass --force to overwrite them
                        without complaint''')

    parser.add_argument('--jobs', '-j',
                        type=int,
                        required=False,
                        default=1,
                        help='''parallelize the processing JOBS-ways. This is like GNU make, except you're
                        required to explicitly specify a job count.''')

    parser.add_argument('image',
                        type=lambda f: f if os.path.isfile(f) else \
                                parser.error("The images must be readable files, but got '{}'".format(f)),
                        nargs='+',
                        help='''Images to undistort''')

    return parser.parse_args()

def target_image_filename(f):
    m = re.match("(.*)\.([a-z][a-z][a-z])$", f, flags=re.I)
    if not m:
        raise Exception("imagefile must end in .xxx where 'xxx' is some image extension. Instead got '{}'".format(imagefile))

    return "{}-undistorted.{}".format(m.group(1),m.group(2))



args = parse_args()

if not args.force:
    for imagefile in args.image:
        f = target_image_filename(imagefile)
        if os.path.isfile(f):
            raise Exception("Target image '{}' already exists. Doing nothing, and giving up. Pass -f to overwrite.".format(f))

model = mrcal.cameramodel(args.model[0])

if args.fit is None:
    scale_f_pinhole = 1.0
elif re.match("^(corners|centers-horizontal|centers-vertical)$", args.fit):
    scale_f_pinhole =  mrcal.compute_scale_f_pinhole_for_fit(model, args.fit)
else:
    sys.stderr.write("--fit must be one of ('corners','centers-horizontal','centers-vertical')\n")
    sys.exit(1)


distortion_model,intrinsics_data = model.intrinsics()
if distortion_model == 'DISTORTION_NONE' and scale == 1.0:
    sys.stderr.write("Warning: the input model has no distortions, so the 'undistorted' images are the same as the input\n")

model_pinhole = mrcal.cameramodel( model )
model_pinhole.intrinsics(('DISTORTION_NONE',
                          nps.glue( intrinsics_data[:2]*scale_f_pinhole,
                                    intrinsics_data[2:4],
                                    axis=-1)))

print "Corresponding pinhole model (cameramodel):"
model_pinhole.write(sys.stdout)

print "====================================="
print "Corresponding pinhole model (cahvor):"
model_pinhole.write(sys.stdout, cahvor=True)



def undistort_this(imagefile):
    imagefile_undistorted = target_image_filename(imagefile)

    image_undistorted = mrcal.undistort_image(model, imagefile, scale_f_pinhole=scale_f_pinhole)
    cv2.imwrite(imagefile_undistorted, image_undistorted)
    sys.stderr.write("Wrote {}\n".format(imagefile_undistorted))


# weird business to handle weird signal handling in multiprocessing. I want
# things like the user hitting C-c to work properly. So I ignore SIGINT for the
# children. And I want the parent's blocking wait for results to respond to
# signals. Which means map_async() instead of map(), and wait(big number)
# instead of wait()
signal_handler_sigint = signal.signal(signal.SIGINT, signal.SIG_IGN)
pool = multiprocessing.Pool(args.jobs)
signal.signal(signal.SIGINT, signal_handler_sigint)
try:
    mapresult = pool.map_async(undistort_this, args.image)

    # like wait(), but will barf if something goes wrong. I don't actually care
    # about the results
    mapresult.get(1000000)
except:
    pool.terminate()

pool.close()
pool.join()
