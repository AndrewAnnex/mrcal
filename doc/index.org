#+title: mrcal - camera calibrations and more
#+OPTIONS: toc:nil

mrcal is a toolkit for working with lens models, camera geometry, images,
projections, and the various related operations such as camera calibration. Any
task that produces or consumes camera models can benefit from this toolkit. It
was originally built to generate the high-accuracy calibrations demanded by
long-range stereo, so it provides facilities to analyze the results and to track
down sources of error.

mrcal provides a routine to compute the "[[file:differencing.org][difference]]" between two models, which
can be a fundamental piece of a wide number of analyses, for instance to measure
a lens's response to temperature cycles.

mrcal provides estimates of [[file:uncertainty.org][projection uncertainty]], which can be used to gauge
calibration quality, and to compute the uncertainty of any data products that
use the lens model.

A rich, [[file:lensmodels.org::#Splined stereographic lens model][splined lens model]] is available to fit any projection function and to
provide realistic uncertainty estimates.

The core functionality is exposed from the [[file:c-api.org][C API]], while higher-level routines
are available through [[file:python-api.org][Python]]. The most common workflows are available as
[[file:commandline-tools.org][commandline tools]], with no coding required.

[[https://docs.opencv.org/master/][OpenCV]] is a big library that provides some of the same facilities, but it can't
produce calibrations that are as good, and it can't tell you why.

The mrcal toolkit has APIs in both C and Python. Everything that could
potentially be slow is written in C, but the higher-level logic is mostly in
Python. The Python-wrapping is done via the [[https://github.com/dkogan/numpysane/blob/master/README-pywrap.org][=numpysane_pywrap=]] library, which
makes it fairly simple to build the Python interfaces in a standard way, so over
time Python-only functionality will be translated to C, as needed (with
backwards-compatible Python wrappers replacing the Python implementations).

* Documentation index

Please see [[file:tour.org][a tour of mrcal]] for a high-level overview of the capabilities of the
toolkit.

Before using mrcal in any way, it is helpful to read about the [[file:conventions.org][terminology and
conventions]] employed by the tookit.

At the core of a calibration routine is an optimization problem. Details about
its [[file:formulation.org][formulation]] are useful to know to be able to interpret the results.

A camera lens can be represented by any of a number of [[file:lensmodels.org][lens models]].

A [[file:how-to-calibrate.org][how-to-calibrate-some-cameras]] page describes details about how to achieve this
very common task.

After running a calibration, the camera models are written to [[file:cameramodels.org][files on disk]].

We can then use these files with a number of [[file:commandline-tools.org][command-line tools]]. In particular,
we can [[file:differencing.org][compare the projection behaviors of different models]]. And we can [[file:uncertainty.org][compute
the projection uncertainty]] of a model.

If we need to do something more than what the pre-made tools can do, there're
two sets programmatic interfaces available:

- [[file:c-api.org][The C API to provide a growing set of core functionality]]
- [[file:python-api.org][The Python API to do everything else]]

* Build and/or install
yyy

* License and copyright
Copyright 2017-2020 California Institute of Technology

This is all proprietary for now.

* future work                                                      :noexport:
- measure observed_pixel_uncertainty
- use uncertainty in triangulation, deltapose, stereo
- improve uncertainty method: faraway obervations don't make things worse
- projection_uncertainty() should be able to project multiple points at a time,
  and to report correlations in the projection. Should work with multiple
  cameras somehow (could calibration more than one camera at the same time)
- splined models should behave more nicely at the edges
- better regularization scheme for the splined models. I should pull not towards
  0 but towards the mean. I had an implementation in
  c8f9918023142d7ee463821661dc5bcc8f770b51 that I reverted because any planar
  splined surface would have "perfect" regularization, and that was breaking
  things (crazy focal lengths would be picked). But now that I'm locking down
  the intrinsics core when optimizing splined models, this isn't a problem anymore
- SFM
- integrate deltapose-lite
- can I quantify the heteroscedasticity and thus the model-nonfitting and the
  resulted expected bias? White test?
- study cubic/quadratic splines, spline density effects
- do a triangulation with explict uncertainty propagation
- Redo, show stability. Heat? Show effects?
- Can we study intrinsics stability over time? In response to heating? Shaking?
- Can we use a 3-parallel calibration to quantify chromatic aberration?
- Measure effect of focus, aperture
- cahvore linearity should be a config parameter
- cahvore: non-gradientness should be a metadata parameter
- stereo.py should be a separate tool
- better outlier rejection. cook's D

* todo for the document                                            :noexport:
document m-c-c and/or mrcal.optimize and/or mrcal_optimize

stereo. Try opencv rectification
diffs
Add some sort of "visualization" section

something somewhere should describe the optimizer_callback()

Somewhere talk about these:
  - [[file:mrcal-python-api-reference.html#-ingest_packed_state][=mrcal.ingest_packed_state()=]]: Read a given packed state into optimization_inputs
  - [[https://github.jpl.nasa.gov/maritime-robotics/mrcal/blob/master/mrcal.h][=mrcal_corresponding_icam_extrinsics()=]]
  - [[file:mrcal-python-api-reference.html#-corresponding_icam_extrinsics][=mrcal.corresponding_icam_extrinsics()=]]: Return the icam_extrinsics corresponding to a given icam_intrinsics

tour: stereo shouldn't use deltapose, but a procrustes fit. Much better demo

license statements for things I'm using
