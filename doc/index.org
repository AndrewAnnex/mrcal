#+title: mrcal - camera calibrations and more
#+OPTIONS: toc:nil

mrcal is a toolkit for working with lens models, camera geometry, images,
projections, and the various related operations such as camera calibration. Any
task that produces or consumes camera models can benefit from this toolkit. It
was originally built to generate the high-accuracy calibrations demanded by
long-range stereo, so it provides facilities to analyze the results and to track
down sources of error.

A common library people use to solve similar problems is [[https://docs.opencv.org/master/][OpenCV]]. This library
does much more that mrcal does, but it can't produce calibrations that are as
good, and it can't tell you why.

* Documentation index

Please see [[file:tour.org][a tour of mrcal]] for a high-level overview of the capabilities of the
toolkit.

Before using mrcal in any way, it is helpful to read about the [[file:conventions.org][terminology and
conventions]] employed by the tookit.

At the core of a calibration routine is an optimization problem. Details about
its [[file:formulation.org][formulation]] are useful to know to be able to interpret the results.

A camera lens can be represented by any of a number of [[file:lensmodels.org][lens models]].

A [[file:how-to-calibrate.org][how-to-calibrate-some-cameras]] page describes details about how to accomplish
this very common task.

After running a calibration, the camera models are written to [[file:cameramodels.org][files on disk]].

We can then use these files with a number of [[file:commandline-tools.org][command-line tools]]. In particular,
we can [[file:differencing.org][compare the projection behaviors of different models]]. And we can [[file:uncertainty.org][compute
the projection uncertainty]] of a model.

If we need to do something more than what the pre-made tools can do, there're
two sets programmatic interfaces available:

- [[file:c-api.org][The C API to provide a growing set of core functionality]]
- [[file:python-api.org][The Python API to do that and a whole lot more]]

* Build and/or install
yyy

* Author
Dima Kogan =kogan@jpl.nasa.gov=

* License and copyright
Copyright 2017-2020 California Institute of Technology

This is all proprietary for now.

* future work                                                      :noexport:
- measure observed_pixel_uncertainty
- use uncertainty in triangulation, deltapose, stereo
- improve uncertainty method: faraway obervations don't make things worse
- projection_uncertainty() should be able to project multiple points at a time,
  and to report correlations in the projection. Should work with multiple
  cameras somehow (could calibration more than one camera at the same time)
- splined models should behave more nicely at the edges
- better regularization scheme for the splined models. I should pull not towards
  0 but towards the mean. I had an implementation in
  c8f9918023142d7ee463821661dc5bcc8f770b51 that I reverted because any planar
  splined surface would have "perfect" regularization, and that was breaking
  things (crazy focal lengths would be picked). But now that I'm locking down
  the intrinsics core when optimizing splined models, this isn't a problem anymore

#+begin_example
Notes from sources:

splined regularization should penalize dqx/dvx<0. It should be >0 everywhere.
The splined representation COULD flip that around, however, and I should fight
that. This would make the function non-reversible uniquely, and unproject()
could have trouble

  q = (u + deltau(u)) * f + c
  dqx/dpx ~ (d(ux + deltaux(u))/dpx) =
          = dux/dpx + ddeltaux(u)/du du/dpx
  u = xy / (mag_p + z) * 2, so
  dqx/dpx ~ ((mag_p + z) - x^2/mag_p)/(mag_p + z)^2 +
            ddeltaux(u)/du ((mag_p + z) I - outer(xy,xy)/mag_p)/(mag_p + z)^2
  I care about the sign only, so
  dqx/dpx ~ (mag_p + z) - x^2/mag_p +
#+end_example


- SFM
- integrate deltapose-lite
- can I quantify the heteroscedasticity and thus the model-nonfitting and the
  resulted expected bias? White test?
- study cubic/quadratic splines, spline density effects
- do a triangulation with explict uncertainty propagation
- Redo, show stability. Heat? Show effects?
- Can we study intrinsics stability over time? In response to heating? Shaking?
- Can we use a 3-parallel calibration to quantify chromatic aberration?
- Measure effect of focus, aperture
- cahvore linearity should be a config parameter
- cahvore: non-gradientness should be a metadata parameter
- stereo.py should be a separate tool
- better outlier rejection. cook's D

* todo for the document                                            :noexport:
document m-c-c and/or mrcal.optimize and/or mrcal_optimize

stereo. Try opencv rectification
diffs
Add some sort of "visualization" section

something somewhere should describe the optimizer_callback()

Somewhere talk about these:
  - [[file:mrcal-python-api-reference.html#-ingest_packed_state][=mrcal.ingest_packed_state()=]]: Read a given packed state into optimization_inputs
  - [[https://github.jpl.nasa.gov/maritime-robotics/mrcal/blob/master/mrcal.h][=mrcal_corresponding_icam_extrinsics()=]]
  - [[file:mrcal-python-api-reference.html#-corresponding_icam_extrinsics][=mrcal.corresponding_icam_extrinsics()=]]: Return the icam_extrinsics corresponding to a given icam_intrinsics

tour: stereo shouldn't use deltapose, but a procrustes fit. Much better demo

license statements for things I'm using

somewhere should talk about how using reprojection errors for quality evaluation
is a bad idea

* Copyrights                                                       :noexport:
doc.pydoc.py:  Agreement and PSF's notice of copyright, i.e., "Copyright (c) 2001,


../mrbuild/Makefile.common.footer:# Copyright 2016-2019 California Institute of Technology
../mrbuild/Makefile.common.header:# Copyright 2016-2019 California Institute of Technology

# Released under an MIT-style license. Modify and distribute as you like:
#
# Copyright 2016-2019 California Institute of Technology


mrcal.c: opencv projection based on their code
//
// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
// Copyright (C) 2009, Willow Garage Inc., all rights reserved.
// Third party copyrights are property of their respective owners.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:



mrcal/poseutils.py
quat_from_R(): 
Copyright (c) 2001-2002 Enthought, Inc.  2003-2019, SciPy Developers.

poseutils.c:
// The implementations of mrcal_r_from_R and mrcal_R_from_r are based on opencv.
// The sources have been heavily modified, but the opencv logic remains.
//
// from opencv-4.1.2+dfsg/modules/calib3d/src/calibration.cpp
//
// Copyright (C) 2000-2008, Intel Corporation, all rights reserved.
// Copyright (C) 2009, Willow Garage Inc., all rights reserved.
// Third party copyrights are property of their respective owners.
