#+title: mrcal - camera calibrations and more

mrcal is a toolkit for working with lens models, camera geometry, images,
projections, and the various related operations such as camera calibration. Any
task that produces or consumes camera models can benefit from this toolkit. It
was originally built to generate the high-accuracy calibrations demanded by
long-range stereo, so it provides facilities to analyze the results and to track
down sources of error.

mrcal provides a routine to compute the "[[file:differencing.org][difference]]" between two models, which
can be a fundamental piece of a wide number of analyses, for instance to measure
a lens's response to temperature cycles.

mrcal provides estimates of [[file:uncertainty.org][projection uncertainty]], which can be used to gauge
calibration quality, and to compute the uncertainty of any data products that
use the lens model.

A rich, [[file:lensmodels.org::#Splined stereographic lens model][splined lens model]] is available to fit any projection function and to
provide realistic uncertainty estimates.

The core functionality is exposed from the [[file:c-api.org][C API]], while higher-level routines
are available through [[file:python-api.org][Python]]. The most common workflows are available as
[[file:commandline-tools.org][commandline tools]], with no coding required.

[[https://docs.opencv.org/master/][OpenCV]] is a big library that provides some of the same facilities, but it can't
produce calibrations that are as good, and it can't tell you why.

Please see [[file:tour.org][a tour of mrcal]] for a high-level overview of the capabilities of the
toolkit.

* Developer manual (APIs)
The mrcal toolkit has APIs in both C and Python. Everything that could
potentially be slow is written in C, but the higher-level logic is mostly in
Python. The Python-wrapping is done via the [[https://github.com/dkogan/numpysane/blob/master/README-pywrap.org][=numpysane_pywrap=]] library, which
makes it fairly simple to build the Python interfaces in a standard way, so over
time Python-only functionality will be translated to C, as needed (with
backwards-compatible Python wrappers replacing the Python implementations).

* Calibration object
:PROPERTIES:
:CUSTOM_ID: Calibration object
:END:
This is called a "chessboard" or just "board" in some parts of the code. The
optimization code refers to the chessboard pose array as "frames".

When running a camera calibration, we use observations of a known-geometry
object. At this time mrcal expects this object to be a planar grid of observable
points, with possibly a small amount of [[#board deformation][deformation]].

Usually this object is a chessboard-like grid of black and white squares, where
the observed points are the corners between squares. These are detected and
serve as the input features to mrcal. mrcal is a purely geometrical toolkit, so
this vision problem must be handled by another library. I recommend [[https://github.com/dkogan/mrgingham/][=mrgingham=]],
but any other source of grid observations may be used.

When given an image of a chessboard, the detector is directly observing the
feature we actually care about. Another common calibration board style is a grid
of circles. When given an image of a grid of circles, the detector sees the edge
of each circle, and then infers the circle center. This is difficult to do
accurately when given tilted images subjected to arbitrary lens behaviors. The
resulting inaccuracies in detections of the circle centers will introduce biases
into the solve that aren't modeled by the [[file:uncertainty.org::#noise model][projection uncertainty routine]], so
chessboards are /strongly/ recommended.

mrcal [[file:uncertainty.org::#noise model][assumes independent noise]] on each point observation, so correlated sources
of points (such as corners of an apriltag) are also not appropriate sources of
data currently. Apriltag centers would work, however.

** Board deformation
:PROPERTIES:
:CUSTOM_ID: board deformation
:END:

The calibration object is assumed to be planar. However, large calibration
boards used for calibration of wide lenses are never flat: temperature and
humidity effects deform the board strongly-enough to affect the calibration.
mrcal models this deformation with two axis-aligned parabolic factors. If the
chessboard grid spans $[-1,1]$ along the $x$ and $y$ axes, then I define the
non-planar deformation as $z \equiv k_x (1 - x^2) + k_y (1 - y^2)$ with $k_x$
and $k_y$ being the two deformation factors being optimized by the solver.

Empirically, this appears to work well: I get better-fitting solves, and less
systematic error. And the optimal deformation factors $k_x$, $k_y$ are
consistent between different calibrations. A richer deformation model could work
even better, and will eventually be the studied.


* future work                                                      :noexport:
- measure observed_pixel_uncertainty
- use uncertainty in triangulation, deltapose, stereo
- improve uncertainty method: faraway obervations don't make things worse
- projection_uncertainty() should be able to project multiple points at a time,
  and to report correlations in the projection. Should work with multiple
  cameras somehow (could calibration more than one camera at the same time)
- splined models should behave more nicely at the edges
- better regularization scheme for the splined models. I should pull not towards
  0 but towards the mean. I had an implementation in
  c8f9918023142d7ee463821661dc5bcc8f770b51 that I reverted because any planar
  splined surface would have "perfect" regularization, and that was breaking
  things (crazy focal lengths would be picked). But now that I'm locking down
  the intrinsics core when optimizing splined models, this isn't a problem anymore
- SFM
- integrate deltapose-lite
- can I quantify the heteroscedasticity and thus the model-nonfitting and the
  resulted expected bias? White test?
- study cubic/quadratic splines, spline density effects
- do a triangulation with explict uncertainty propagation
- Redo, show stability. Heat? Show effects?
- Can we study intrinsics stability over time? In response to heating? Shaking?
- Can we use a 3-parallel calibration to quantify chromatic aberration?
- Measure effect of focus, aperture
- cahvore linearity should be a config parameter
- cahvore: non-gradientness should be a metadata parameter
- stereo.py should be a separate tool
- better outlier rejection. cook's D

* todo for the document                                            :noexport:
document m-c-c and/or mrcal.optimize and/or mrcal_optimize

stereo. Try opencv rectification
diffs
Add some sort of "visualization" section

something somewhere should describe the optimizer_callback()

Somewhere talk about these:
  - [[file:mrcal-python-api-reference.html#-ingest_packed_state][=mrcal.ingest_packed_state()=]]: Read a given packed state into optimization_inputs
  - [[https://github.jpl.nasa.gov/maritime-robotics/mrcal/blob/master/mrcal.h][=mrcal_corresponding_icam_extrinsics()=]]
  - [[file:mrcal-python-api-reference.html#-corresponding_icam_extrinsics][=mrcal.corresponding_icam_extrinsics()=]]: Return the icam_extrinsics corresponding to a given icam_intrinsics

tour: stereo shouldn't use deltapose, but a procrustes fit. Much better demo
