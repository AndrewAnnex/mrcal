#+TITLE: Dense stereo processing
#+OPTIONS: toc:t

* Overview
Given a pair of calibrated (both intrinsics and extrinsics) cameras, mrcal can
perform stereo processing to produce a dense stereo map. This is relatively
slow, and is often overkill for what is actually needed. But sometimes it is
useful, and the resulting depth images look /really/ nice.

On a high level, mrcal stereo processing is the usual [[https://en.wikipedia.org/wiki/Epipolar_geometry][epipolar geometry]]
technique:

1. Ingest
   - Two camera models, each containing the intrinsics /and/ extrinsics (the
     relative pose between the two cameras)
   - A pair of images captured by these two cameras
2. Compute a "rectified" system: a pair of models where each corresponding row
   of pixels in the two cameras all represent observation rays that lie in the
   same /epipolar/ plane
3. Reproject the images to these rectified models to produce /rectified/ images
4. Perform "stereo matching". For each pixel in the left rectified image we try
   to find the corresponding pixel in the same row of the right rectified image.
   The difference in columns is written to a /disparity/ image. This is the most
   computationally-intensive part of the process.
5. Convert the /disparity/ image to a /range/ image using the geometry defined
   by the rectified system

The epipolar constraint (all pixels in the same row in both rectified images
represent the same plane in space) allows for one-dimensional stereo matching,
which is a massive computational win over the two-dimensional matching that
would be required with another formulation.

The rectified coordinate system looks like this:

[[file:figures/rectification.svg]]

The code and documentatio refers to two angles:

- $\theta$: the "azimuth"; the lateral angle inside the epipolar plane. Related
  directly to the $x$ pixel coordinate in the rectified images
- $\phi$: the "elevation"; the tilt of the epipolar plane. Related directly to
  the $y$ pixel coordinate in the rectified images

* Rectification models
:PROPERTIES:
:CUSTOM_ID: stereo-rectification-models
:END:

A rectified system satisfies the epipolar constraint (see above). mrcal supports
two models that can have this property, selected with the =rectification_model=
argument to [[file:mrcal-python-api-reference.html#-rectified_system][=mrcal.rectified_system()=]] or with the =--rectification= commandline
argument to [[file:mrcal-stereo.html][=mrcal-stereo=]].

- [[file:lensmodels.org::#lensmodel-pinhole][=LENSMODEL_PINHOLE=]]: this is the traditional rectification model, used in most
  existing tools. This works decently well for small fields of view (as with a
  long lens), but fails with large fields of view (as with a wide lens). The
  issues stem from the uneven angular resolution across the image, which shoots
  out to $\infty \frac{\mathrm{pixels}}{\mathrm{deg}}$ as $\theta \rightarrow
  \pm 90^\circ$. This produces highly distorted rectified images, which affects
  stereo matching adversely, since areas of disparate resolution are being
  compared. This is supported by mrcal purely for compatibility with other
  tools; there's little reason to use this representation otherwise

- [[file:lensmodels.org::#lensmodel-latlon][=LENSMODEL_LATLON=]]: this is a "transverse equirectangular projection". It is
  defined with even angle spacing in both directions, so $x - x_0 = k_x \theta$
  and $y - y_0 = k_y \phi$ where $x$ and $y$ are pixel coordinates in the
  rectified images, $x_0$ and $y_0$ are the centers of projection of the
  rectified system and $k_x$ and $k_y$ are the angular resolution in the two
  directions. This is the recommended rectification model, and is the default in
  mrcal

Let's demonstrate the two rectification models. In the [[file:tour-stereo.org][tour of mrcal]] we showed a
dense stereo processing sequence. Let's re-rectify those same images and models
with =LENSMODEL_PINHOLE= and =LENSMODEL_LATLON=. This is just a demo of
rectification, so I ask for the same pixels/angle resolution at the center of
the image in both cases: 1/20 of the resolution of the original image. I do
this:

#+begin_src sh
for model (LENSMODEL_PINHOLE LENSMODEL_LATLON) {
  mrcal-stereo                     \
    --az-fov-deg 160               \
    --el-fov-deg 140               \
    --pixels-per-deg -0.05         \
    --rectification $model         \
    [01].cameramodel               \
    [01].jpg
}
#+end_src
#+begin_src sh :exports none :eval no-export
D=~/projects/mrcal-doc-external/2022-11-05--dtla-overpass--samyang--alpha7/stereo
Dout=~/projects/mrcal-doc-external/figures/stereo
mkdir -p $Dout

for model (LENSMODEL_PINHOLE LENSMODEL_LATLON) {
$PYTHONPATH/mrcal-stereo         \
  --az-fov-deg 160               \
  --el-fov-deg 140               \
  --pixels-per-deg -0.05         \
  --rectification $model         \
  --outdir /tmp                  \
  --force                        \
  $D/[01].cameramodel            \
  $D/[01].jpg

  mv /tmp/0-rectified.png $Dout/rectified-demo-lowres-${${model/LENSMODEL_/}:l}.png
}
#+end_src

The left image rectified with =LENSMODEL_LATLON=:

[[file:external/figures/stereo/rectified-demo-lowres-latlon.png]]

The left image rectified with =LENSMODEL_PINHOLE=:

[[file:external/figures/stereo/rectified-demo-lowres-pinhole.png]]

These are the actual, unscaled rectified images. Note the identical resolution
at the center of the image. And note how =LENSMODEL_PINHOLE= rectification
causes the image to expand dramatically as we approach the edges, which
=LENSMODEL_LATLON= does not do.

Using =LENSMODEL_PINHOLE= with wide lenses like this introduces an unwinnable
trade-off. If you choose the pixels/angle resolution to keep all your
information at the center, you'll get a huge image, with large low-information
pixels at the edges. But if you want to control this expansion by reducing the
resolution, you'll lose data at the center. Cutting off the edges works too, so
all methods entail throwing out information, in some form.

Or you can use =LENSMODEL_LATLON=.

* Interfaces
Currently stereo processing is available via the [[file:mrcal-stereo.html][=mrcal-stereo=]] tool. This tool
implements the usual stereo processing for a single frame.

More complex usages are available via Python APIs. A sequence of images captured
with a stereo pair can be processed like this:

1. [[file:mrcal-python-api-reference.html#-rectified_system][=mrcal.rectified_system()=]] to construct the rectified system defined by the
   stereo pair
2. [[file:mrcal-python-api-reference.html#-rectification_maps][=mrcal.rectification_maps()=]] to construct the pixel mappings needed to
   transform captured images into rectified images. This is relatively slow, but
   it depends on the relative stereo geometry only, so this can be computed
   once, and applied to /all/ the subsequent images captured by the stereo pair
3. For each pair of captured images
   - [[file:mrcal-python-api-reference.html#-transform_image][=mrcal.transform_image()=]] to generate rectified images
   - stereo matching to compute disparities. mrcal does not provide its own
     method, and the [[file:mrcal-stereo.html][=mrcal-stereo=]] tool uses the [[https://docs.opencv.org/4.5.3/d2/d85/classcv_1_1StereoSGBM.html][OpenCV SGBM stereo matcher]].
     Any stereo matcher can be used. The result is a /disparity/ image, where
     each pixel in the first rectified image is mapped to a corresponding pixel
     offset from the same feature in the second rectified image
   - [[file:mrcal-python-api-reference.html#-stereo_range][=mrcal.stereo_range()=]] to convert the disparities to ranges, which can then
     be used to produce a point cloud

A demo of the process if shown in the [[file:tour-stereo.org][tour of mrcal]].

* Interoperating with other tools
As described above, the full dense-stereo sequence is composed of many steps,
some of which require mrcal-specific logic. Specifically:

1. For successful long-range stereo we need maximum precision in our lens
   models. mrcal supports [[file:splined-models.org][=LENSMODEL_SPLINED_STEREOGRAPHIC=]]: a rich model that
   is able to describe the behavior of real-world lenses more precisely than the
   parametric models used by other tools. This is good, but today, a calibration
   based on this model cannot be used in any tool other than mrcal.

2. Furthermore, mrcal can use a [[#stereo-rectification-models][transverse
   equirectangular rectification function]] to describe the rectified system
   instead of the more traditional pinhole rectification function. This allows
   nice stereo matching even with wide lenses, but once again: these rectified
   models and images can only be consumed with mrcal.




Suppose you computed some very accurate calibrations using a [[file:splined-models.org][mrcal splined
model]], and you want to use them in a non-mrcal-aware tool. This tools cannot
use the mrcal splined models, so there are several options to take advantage

1. partial mrcal. rectify with mrcal then correlate with something else
2. fit opencv5 into the splined model, which would lose accuracy
     http://mrcal.secretsauce.net/mrcal-convert-lensmodel.html

   You can throw out corners. You get a tradeoff between fov/accuracy

3. fit and reproject
     http://mrcal.secretsauce.net/mrcal-convert-lensmodel.html
     http://mrcal.secretsauce.net/mrcal-reproject-image.html

* Stereo rectification outside of mrcal
As a toolkit, mrcal is fairly flexible, so I want to show how one could perform
stereo processing using other tools a part of the pipeline, rather than letting
[[file:mrcal-stereo.html][=mrcal-stereo=]] do all the work.

What if we want to do our stereo processing with some other tool, and what if
that tool doesn't support the splined model we want to use? We can use mrcal to
reproject the image to whatever model we like, and then hand off the processed
image and new models to that tool. Let's demonstrate with a pinhole model.


* Splitting a wide view into multiple narrow views
We just showed one way to use jplv to handle mrcal lenses, but we had to pay a
price of degraded feature-matching accuracy due to unevenly-scaled rectified
images. A way to do pinhole-rectified stereo while handling the geometric
challenges of wide-angle lenses is to subdivide the wide field of view into
multiple narrower virtual views. Then we'd have several narrow-angle stereo
pairs instead of a single wide stereo pair, and each narrow pair can be
processed with pinhole rectification. [[file:mrcal-stereo.html][=mrcal-stereo=]] can do all the work. Let's
look 45 degrees to the left:

#+begin_src sh
mrcal-stereo                        \
  --rectification LENSMODEL_PINHOLE \
  --az-fov-deg 80                   \
  --el-fov-deg 80                   \
  --az0-deg    -45                  \
  --disparity-range 0 200           \
  --sgbm-p1 600                     \
  --sgbm-p2 2400                    \
  --sgbm-uniqueness-ratio 5         \
  --sgbm-disp12-max-diff 1          \
  --sgbm-speckle-window-size 200    \
  --sgbm-speckle-range 2            \
  --valid-intrinsics-region         \
  [01].cameramodel          \
  [01].jpg
#+end_src
#+begin_src sh :exports none :eval no-export
D=~/projects/mrcal/doc/external/2022-11-05--dtla-overpass--samyang--alpha7/2-f22-infinity
D1=$D/data/figueroa-overpass-looking-S/

PYTHONPATH=~/projects/mrcal;
export PYTHONPATH
$PYTHONPATH/mrcal-stereo            \
  --rectification LENSMODEL_PINHOLE \
  --az-fov-deg 80                   \
  --el-fov-deg 80                   \
  --az0-deg    -45                  \
  --disparity-range 0 200           \
  --sgbm-p1 600                     \
  --sgbm-p2 2400                    \
  --sgbm-uniqueness-ratio 5         \
  --sgbm-disp12-max-diff 1          \
  --sgbm-speckle-window-size 200    \
  --sgbm-speckle-range 2            \
  --valid-intrinsics-region         \
  --outdir /tmp                     \
  -f                                \
  $D/[01].cameramodel      \
  $D/[01].jpg

zmv -f -W \
  '/tmp/[01]-rectified.png' \
  "$D/figures/stereo/rectified[01]-narrow-splined.png"

mv \
  /tmp/0-disparity.png \
  $D/figures/stereo/disparity-narrow-splined.png

mv \
  /tmp/0-range.png \
  $D/figures/stereo/range-narrow-splined.png

for img ( $D/figures/stereo/{rectified[01],disparity,range}-narrow-splined.png ) { \
  convert $img -scale 12% ${img:r}.downsampled.${img:e}
}
#+end_src

The pinhole rectified images:

[[file:external/2022-11-05--dtla-overpass--samyang--alpha7/stereo/rectified0-narrow-splined.png][file:external/2022-11-05--dtla-overpass--samyang--alpha7/stereo/rectified0-narrow-splined.downsampled.png]]
[[file:external/2022-11-05--dtla-overpass--samyang--alpha7/stereo/rectified1-narrow-splined.png][file:external/2022-11-05--dtla-overpass--samyang--alpha7/stereo/rectified1-narrow-splined.downsampled.png]]

And the disparity:

[[file:external/2022-11-05--dtla-overpass--samyang--alpha7/stereo/disparity-narrow-splined.png][file:external/2022-11-05--dtla-overpass--samyang--alpha7/stereo/disparity-narrow-splined.downsampled.png]]

This looks much better than the pinhole-rectified stereo from the full image.
The rectified pinhole models and images could be passed to a different tool to
complete the processing, if desired.

And we can see the rotated field of view when we visualize the rectified system:

#+begin_src sh
mrcal-stereo                        \
  --rectification LENSMODEL_PINHOLE \
  --az-fov-deg 80                   \
  --el-fov-deg 80                   \
  --az0-deg    -45                  \
  --set 'view 70,5'                 \
  --viz geometry                    \
  [01].cameramodel
#+end_src
#+begin_src sh :exports none :eval no-export
PYTHONPATH=~/projects/mrcal;
export PYTHONPATH
$PYTHONPATH/mrcal-stereo                                            \
  --rectification LENSMODEL_PINHOLE                                 \
  --az-fov-deg 80                                                   \
  --el-fov-deg 80                                                   \
  --az0-deg    -45                                                  \
  --set 'view 70,5'                                                 \
  --viz geometry                                                    \
  --hardcopy $Dout/stereo-rectified-system-narrow.svg               \
  --terminal 'svg size 800,600 noenhanced solid dynamic font ",14"' \
  $D/[01].cameramodel
#+end_src

[[file:external/2022-11-05--dtla-overpass--samyang--alpha7/stereo/stereo-rectified-system-narrow.svg]]

