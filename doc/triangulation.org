#+TITLE: Triangulation uncertainty
#+OPTIONS: toc:t

#+LATEX_HEADER: \DeclareMathOperator*{\argmin}{argmin}

#+BEGIN_HTML
\(
\DeclareMathOperator*{\argmin}{argmin}
\)
#+END_HTML


A very common thing to want to do with a calibrated camera system is to convert
a pair of pixel observations to a point in space that produced these
observations, a process known as [[https://en.wikipedia.org/wiki/Triangulation_(computer_vision)][triangulation]] (or [[file:stereo.org][stereo vision]], which is an
efficient formulation of the same). This can be sensitive to noise, creating a
strong need for proper error modeling and propagation. Let's say we have an
idealized geometry:

[[file:figures/triangulation-symmetric.svg]]

Let $b \equiv \mathrm{baseline}$ and $r \equiv \mathrm{range}$. Two cameras are
looking at a point in space. Given two camera models and a pair of pixel
observations we can compute the range to the point. Basic geometry tells us that

\[\sin \theta \propto \frac{b}{r}\]

Differentiating, we get

\[\cos \theta \; \mathrm{d}\theta \propto \frac{b}{r^2} \mathrm{d}r\]

When looking far away $\theta \approx 0$, so

\[\frac{\mathrm{d}r}{\mathrm{d}\theta} \propto \frac{r^2}{b}\]


Thus a small error in $\theta$ causes an error in the computed range that is
proportional to the /square/ of $r$. This relationship sets the fundamental
limit for the ranging capabilities of stereo systems: if you try to look out too
far, the precision of $\theta$ required to get a precise-enough $r$ becomes
unattainable. And because we have $r^2$, this range limit is approached very
quickly. A bigger baseline helps, but does so only linearly.

The angle $\theta$ comes from the extrinsics and intrinsics in the camera model,
so the noise modeling and uncertainty propagation in mrcal are essential to a
usable long-range stereo system.

* Triangulation routines

Each triangulation operation takes as input

- Two camera models. Intrinsics (lens behavior) and extrinsics (geometry) is
  required for both

- Pixel coordinates $\vec q$ of the same feature in the two images captured by
  each camera

And it computes

- A 3D coordinate of the point $\vec p$ in space that produced the given pixel
  observations

The "right" way to implement this operation is to minimize the reprojection
error:

\[
E\left(\vec p\right) \equiv \left\lVert \vec q_0 - \mathrm{project}_\mathrm{cam0}\left(\vec p\right) \right\rVert^2 +
                            \left\lVert \vec q_1 - \mathrm{project}_\mathrm{cam1}\left(\vec p\right) \right\rVert^2
\]

\[
\vec p^* \equiv \argmin{E\left(\vec p\right)}
\]

This is correct, but it's complex, and requires a nonlinear optimization, which
limits the usefulness of this approach. mrcal implements several
slightly-imprecise but /much/ faster methods to compute a triangulation. All of
these precompute $\vec v \equiv \mathrm{unproject} \left( \vec q \right)$, and
then operate purely geometrically. The methods are described in these papers,
listed in chronological order:

- "Triangulation Made Easy", Peter Lindstrom. IEEE Conference on Computer Vision
  and Pattern Recognition, 2010

- "Closed-Form Optimal Two-View Triangulation Based on Angular Errors", Seong Hun
  Lee and Javier Civera. https://arxiv.org/abs/1903.09115

- "Triangulation: Why Optimize?", Seong Hun Lee and Javier Civera
  https://arxiv.org/abs/1907.11917

The last paper compares the available methods from /all/ the papers. Currently
=leecivera_mid2= is recommended for most usages. The methods:

** =geometric=
This is the basic [[https://en.wikipedia.org/wiki/Triangulation_(computer_vision)#Mid-point_method][midpoint method]]: it computes the point in space that minimizes
the distance between the two observation rays. This is the simplest method, but
also produces the most bias. Not recommended. Implemented in
[[file:mrcal-python-api-reference.html#-triangulate_geometric][=mrcal.triangulate_geometric()=]] (in Python) and [[https://www.github.com/dkogan/mrcal/blob/master/triangulation.h#mrcal_triangulate_geometric][=mrcal_triangulate_geometric()=]]
(in C).

** =lindstrom=
Described in the "Triangulation Made Easy" paper above. The method is a close
approximation to a reprojection error minimization /if we have pinhole lenses/.
Implemented in [[file:mrcal-python-api-reference.html#-triangulate_lindstrom][=mrcal.triangulate_lindstrom()=]] (in Python) and
[[https://www.github.com/dkogan/mrcal/blob/master/triangulation.h#mrcal_triangulate_lindstrom][=mrcal_triangulate_lindstrom()=]] (in C).

** =leecivera_l1=
Described in the "Closed-Form Optimal Two-View Triangulation Based on Angular
Errors" paper above. Minimizes the L1 norm of the observation angle error.
Implemented in [[file:mrcal-python-api-reference.html#-triangulate_leecivera_l1][=mrcal.triangulate_leecivera_l1()=]] (in Python) and
[[https://www.github.com/dkogan/mrcal/blob/master/triangulation.h#mrcal_triangulate_leecivera_l1][=mrcal_triangulate_leecivera_l1()=]] (in C).

** =leecivera_linf=
Described in the "Closed-Form Optimal Two-View Triangulation Based on Angular
Errors" paper above. Minimizes the L-infinity norm of the observation angle
error. Implemented in [[file:mrcal-python-api-reference.html#-triangulate_leecivera_linf][=mrcal.triangulate_leecivera_linf()=]] (in Python) and
[[https://www.github.com/dkogan/mrcal/blob/master/triangulation.h#mrcal_triangulate_leecivera_linf][=mrcal_triangulate_leecivera_linf()=]] (in C).

** =leecivera_mid2=
Described in the "Triangulation: Why Optimize?" paper above: this is the "Mid2"
method. Doesn't explicitly minimize anything, but rather is a heuristic that
works well in practice. Implemented in [[file:mrcal-python-api-reference.html#-triangulate_leecivera_mid2][=mrcal.triangulate_leecivera_mid2()=]] (in
Python) and [[https://www.github.com/dkogan/mrcal/blob/master/triangulation.h#mrcal_triangulate_leecivera_mid2][=mrcal_triangulate_leecivera_mid2()=]] (in C).

** =leecivera_wmid2=
Described in the "Triangulation: Why Optimize?" paper above: this is the "wMid2"
method. Doesn't explicitly minimize anything, but rather is a heuristic that
works well in practice. Similar to =leecivera_mid2=, but contains a bit of extra
logic to improve the behavior for points very close to the cameras (not
satisfying $r \gg b$). Implemented in [[file:mrcal-python-api-reference.html#-triangulate_leecivera_wmid2][=mrcal.triangulate_leecivera_wmid2()=]] (in
Python) and [[https://www.github.com/dkogan/mrcal/blob/master/triangulation.h#mrcal_triangulate_leecivera_wmid2][=mrcal_triangulate_leecivera_wmid2()=]] (in C).

* stuff

What noise we're propagating

show some example plots

show correlations

Apply to the dtla data (obs only)

Talk about =mrcal-triangulate= tool



perpendicular observation/calibration:

test/test-triangulation-uncertainty.py \
  --do-sample \
  --observed-point -2 0 10 \
  --fixed cam0 \
  --Nsamples 20 \
  --q-calibration-stdev 0.2 \
  --q-observation-stdev 0.2 \
  --q-observation-stdev-correlation 0.5 \
  --make-documentation-plots '' \
  >& /dev/null





skewed observation/calibration:
(stabilization primarily causes the skewing, I think)
test/test-triangulation-uncertainty.py \
  --do-sample \
  --observed-point -2 0 10 \
  --fixed cam0 \
  --Nsamples 20 \
  --q-calibration-stdev 0.5 \
  --q-observation-stdev 0.5 \
  --q-observation-stdev-correlation 0.99 \
  --make-documentation-plots '' \
  --stabilize-coords \
  >& /dev/null
