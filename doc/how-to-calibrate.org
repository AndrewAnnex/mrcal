#+TITLE: How to run a calibration
#+OPTIONS: toc:t

Calibrating cameras is one of the main applications of mrcal, so I describe this
process in some detail here.

* Capturing images
** Calibration object
We need to get images of a [[file:formulation.org::#calibration-object][calibration object]], a board containing an observable
grid of points. mrcal doesn't care where these observations come from: any tool
that can produce a table of corner observations can be utilized. Currently the
recommended method is to use a classical /chessboard/ target, and to employ the
[[https://github.com/dkogan/mrgingham][mrgingham]] detector. The mrgingham documentation has a [[https://github.com/dkogan/mrgingham/raw/master/chessboard.14x14.pdf][.pdf of a chessboard
pattern]] that works well. See the [[file:recipes.org::#non-mrgingham-detector][recipes]] to use a non-mrgingham detector.

*** Chessboard shape
The pattern should be printed and mounted onto a /rigid/ and /flat/ surface to
produce the calibration object. The [[file:formulation.org][optimization problem]] assumes the board shape
to be constant over all the calibration images, and any instability in the board
shape breaks that assumption. Depending on the resolution of the camera and the
amount of calibration accuracy required, even a slightly floppy chessboard can
break things. Don't take this for granted.

Similarly, the optimization problem assumes that the calibration object is
mostly flat. Some amount of deformation is inevitable, so mrcal /does/ support a
simple [[file:formulation.org::#board-deformation][non-planar board]] model, with the board shape being computed as part of
the calibration solve. In my experience, if you try to make sure the board is
flat, this model is enough to fix most of the unavoidable small deflections. If
care isn't taken to ensure the board is flat, the current simple deformation
model is often insufficient to fully model the shape. Don't take this for
granted either. See the [[file:recipes.org::#effect-of-chessboard-shape][recipes]] for notes about how to estimate the magnitude of
effect.

I usually use a square chessboard roughly 1m per side to calibrate my fisheye
lenses. Such a large chessboard often has issues with its shape. To mitigate
these my chessboard is backed by about 1 inch of aluminum honeycomb. This is
expensive, but works well to stabilize the shape. The previous board I was using
is backed with the same amount of /foam/ instead. This is significantly cheaper,
and still pretty good, but noticeably less flat and less rigid. This foam-backed
board does warp with variations in temperature and humidity, but this drift is
slow, and the shape is /usually/ stable long-enough for a chessboard dance. If
you can make one, the aluminum honeycomb-backed boards are strongly recommended.

*** Chessboard size
There's a tradeoff to consider between large and small chessboards. According to
the [[file:tour-choreography.org][dance study]], we want close-ups that fill the imager, so we're choosing
between small chessboards placed near the camera and large chessboards placed
away from the camera.

- If the chessboard is too small, we'd need to place it too close to the camera
  to fill the imager. This will result in the chessboard appearing out of focus.
  This is OK up to a point (see the [[file:recipes.org::#effect-of-unfocused-corners][recipes]]), but extereme out-of-focus images
  should probably be avoided

- If the chessboard is too large, we'd need to place it far from the camera to
  see the whole board, and this would result in worse calibration uncertainties.
  See the [[file:tour-choreography.org][dance study]].

For wide lenses, you generally need larger chessboards. When calibrating an
unfamiliar system I usually try running a calibration with whatever chessboard I
already have, and then analyze the results to see if anything needs to be
changed. It's also useful to rerun the [[file:tour-choreography.org][dance study]] for the specific geometry
being calibrated.

** Image-capturing details
Now that we have a calibration object, this object needs to be shown to the
camera(s). It is important that the images contain clear features. Motion blur
or exposure issues will all cause bias in the resulting calibration.

If calibrating multiple cameras, mrcal will solve for all the intrinsics /and/
extrinsics. There is one strong requirement on the captured images in this case:
the images must be synchronized across all the cameras. This allows mrcal to
assume that if camera A and camera B observed a chessboard at time T, then this
chessboard was at /exactly/ the same location when the two cameras saw it.
Generally this means that either

- The cameras are wired to respond to a physical trigger signal
- The chessboard and cameras were physically fixed (on a tripod, say) at each
  time of capture

Some capture systems have a "software" trigger mode, but this is usually too
loose to produce usable results. A similar consideration exists when using
cameras with a [[https://en.wikipedia.org/wiki/Rolling_shutter][rolling shutter]]. With such cameras it is imperative that
everything remain stationary during image capture, even when only one camera is
involved. See the [[file:recipes.org::#rolling-shutter-and-sync-errors][recipes]].

** Lens settings
Lens intrinsics are usually very sensitive to any mechanical manipulation of the
lens. It is thus strongly recommended to set up the lens it its final working
configuration (focal length, focus distance, aperture), then to mechanically
lock down the settings, and then to gather the calibration data. This often
creates dancing challenges, described in the next section.

If you /really/ need to change the lens settings after calibrating or if you're
concerned about drifting lens mechanics influencing the calibration (you should
be!), see the [[file:recipes.org::#lens-stability][recipes]] for a discussion.

** Dancing
As shown in the [[file:tour-choreography.org][dance study]], the most useful observations to gather are

- close-ups: the chessboard should fill the whole frame as much as possible.

- oblique views: tilt the board forward/back and left/right. I generally tilt by
  ~ 45 degrees. At a certain point the corners become indistinct and the
  detector starts having trouble, but depending on the lens, that point could
  come with quite a bit of tilt. A less dense chessboard eases this also, at the
  cost of requiring more board observations to get the same number of points.

- If calibrating multiple cameras, it is impossible to place a calibration
  object at a location where it's seen by all the cameras /and/ where it's a
  close-up for all the cameras. So you should get close-ups for each camera
  individually, and also get observations common to multiple cameras, that
  aren't necessarily close-ups. The former will serve to define your camera
  intrinsics, and the latter will serve to define your extrinsics (geometry).
  Get just far-enough out to create the joint views. If usable joint views are
  missing, the extrinsics will be undefined, and the solver will complain about
  a "not positive definite" (singular in this case) Hessian.

A dataset composed primarily of tilted closeups produces good results.

If the model will be used to look at far-away objects, care must be taken to
produce a reliable calibration /at long ranges/, not just at the /short/ ranges
where the chessboards were. The primary way to do that is to get close-up
chessboard views. If the close-up range is very different from the working range
(infinity, possibly), the close-up images could be very out-of-focus. The
current thought is that the best thing to do is to get close-up images even if
they're out of focus. The blurry images will have a high uncertainty in the
corner observatoins (hopefully without bias), but the uncertainty improvement
that comes from the near-range chessboard observations more than makes up for
it. In these cases you usually need to get more observations than you normally
would to bring down the uncertainties to an acceptable level. In challenging
situations it's useful to re-run the [[file:tour-choreography.org][dance study]] for the specific use case to
get a sense of what kind of observations are required and what kind of
uncertainties can be expected. See the [[file:tour-choreography.org][dance study]] and the [[file:recipes.org::#effect-of-unfocused-corners][recipes]] for detail.

It is better to have more chessboard data rather than less. mrgingham will throw
away frames where no chessboard can be found, so it is perfectly reasonable to
grab too many images with the expectation that they won't all end up being used
in the computation. I usually aim for about 100 usable frames, but you may get
away with fewer, depending on your specific scenario. The mrcal uncertainty
feedback will tell you if you need more data.

Naturally, intrinsics are accurate only in areas where chessboards were
observed: chessboard observations on the left side of the image tell us little
about lens behavior on the right side. Thus it is imperative to cover the whole
field of view during the chessboard dance. It is often tricky to get good data
at the edges and corners of the imager, so care must be taken. Some chessboard
detectors (mrgingham in particular) only report complete chessboards. This makes
it extra-challenging to obtain good data at the edges: a small motion that
pushes one chessboard corner barely out of bounds causes the whole observation
to be discarded. It is thus /very/ helpful to be able to see a live feed of the
camera as the images are being captured. In either case, checking the coverage
is a great thing to do. The usual way to do this is indirectly: [[file:tour-uncertainty.org][by visualizing
the projection uncertainty]]. Or by [[#Visualization][visualizing the obtained chessboard
detections]] directly.

** Image file-naming convention
With monocular calibrations, there're no requirements on image filenames: use
whatever you like. If calibrating multiple synchronized cameras, however, the
image filenames need to indicate which camera captured each image and at which
time. I generally use =frameFFF-cameraCCC.jpg=. Images with the same =FFF= are
assumed to have been captured at the same instant in time, and =CCC= identifies
the camera. Naming images in this way is sufficient to communicate these
mappings to mrcal.

* Detecting corners
:PROPERTIES:
:CUSTOM_ID: corner-detector
:END:
Most of my testing was done using the [[https://github.com/dkogan/mrgingham][mrgingham]] chessboard corner detector, so I
go into more detail describing that approach. See the [[file:recipes.org::#non-mrgingham-detector][recipes]] for notes about
using other detectors.

** Using mrgingham
Once mrgingham is [[file:install.org][installed]] or built from [[https://github.com/dkogan/mrgingham][source]], it can be run by calling the
=mrgingham= executable. The sample in the [[file:tour-initial-calibration.org][tour of mrcal]] processes [[file:external/2022-11-05--dtla-overpass--samyang--alpha7/2-f22-infinity/images][these images]]
to produce [[file:external/2022-11-05--dtla-overpass--samyang--alpha7/2-f22-infinity/corners.vnl][these chessboard corners]] like this:

#+begin_src sh
mrgingham --jobs 4 --gridn 14 '*.JPG' > corners.vnl 
#+end_src

mrgingham tries to handle a variety of lighting conditions, including varying
illumination across the image, but the corners must exist in the image in some
form.

At this time mrgingham returns /only/ complete chessboard views: if even one
corner of the chessboard couldn't be found, mrgingham will discard the entire
image. Thus it takes care to get data at the edges and in the corners of the
imager. A live preview of the captured images is essential.

Another requirement due to the design of mrgingham is that the board should be
held with a flat edge parallel to the camera xz plane (parallel to the ground,
usually). mrgingham looks for vertical and horizontal sequences of corners, but
if the board is rotated diagonally, then none of these sequences are clearly
"horizontal" or "vertical".

** Visualization
:PROPERTIES:
:CUSTOM_ID: Visualization
:END:
Once we have a =corners.vnl= from some chessboard detector, we can visualize the
coverage. This is usually unnecessary since the [[file:tour-uncertainty.org][projection uncertainty reporting]]
shows the coverage (and more!), but it's good to be able to do this in case of
trouble. A sample sequence of corner gathering and visualization appears in the
[[file:tour-initial-calibration.org::#gathering-corners][tour of mrcal]].

* Processing the data
:PROPERTIES:
:CUSTOM_ID: interpreting-results
:END:

The tour of mrcal shows a very detailed calibration process: [[file:tour-initial-calibration.org::#opencv8-model-solving][a real-world fit
using =LENSMODEL_OPENCV8=]] and [[file:tour-initial-calibration.org::#splined-model-solving][a real-world fit using
=LENSMODEL_SPLINED_STEREOGRAPHIC_...=]]. The sequence outlined there is too
thorough for general everyday use, but it's good to look through those pages to
get an overall sense of how this should be done. A high-level process is

- [[#model-choice][Choose a model]]
- [[calibration][Compute the calibration]]
- [[residuals][Examine the residuals to make sure the data is good and that we fit the model
  well-enough]]
- [[uncertainty][Examine the projection uncertainty to make sure we have enough good data in
  the right places]]
- [[cross-validation][Examine the cross-validation diffs to confirm that the model fits and that the
  reported uncertainty is trustworthy]]

Each of these steps is described here.

** Model choice
:PROPERTIES:
:CUSTOM_ID: model-choice
:END:

Use [[file:splined-models.org][=LENSMODEL_SPLINED_STEREOGRAPHIC=]]. These work very well, and are able to
represent real-world lenses better than the parametric models (all the other
ones). This is true even for long, near-pinhole lenses. Depending on the
specific lens and the camera resolution this accuracy improvement may not be
noteworthy. But even in those cases, the splined model is flexible enough to get
truthful [[file:uncertainty.org][projection uncertainty estimates]], so it's /still/ worth using. Today I
use other models only if I'm running quick experiments: splined models have many
more parameters, so things are slower.

[[file:splined-models.org][=LENSMODEL_SPLINED_STEREOGRAPHIC=]] has several [[file:splined-models.org::#splined-models-configuration-selection][configuration variables]] that need
to be set. The full implications of these choices still need to be studied, but
the results appear fairly insensitive to these. I generally choose =order=3= to
select cubic splines. I generally choose a rich model with fairly dense spline
spacing. For instance the splined model used in the [[file:tour-initial-calibration.org][tour of mrcal]] has
=Nx=30_Ny=18=. This has 30 spline knots horizontally and 18 vertically. You
generally want =Ny=/=Nx= to roughly match the aspect ratio of the imager. The
=Nx=30_Ny=18= arrangement is probably far denser than it needs to be, but it
works OK. The cost of such a dense spline is a bit of extra computation time and
more stringent requirements on calibration data fully covering the imager.

The last configuration parameter is =fov_x_deg=: the horizontal field-of-view of
the lens. The splined model is defined by /knots/ spread out across space, the
arrangement of these knots defined by the =fov_x_deg= parameter. We want the
region in space defined by the knots to roughly match the region visible to the
lens. A too-large =fov_x_deg= would waste some knots by placing them beyond
where the lens can see. And a too-small =fov_x_deg= would restrict the
projection representation on the edge of the image.

An initial estimate of =fov_x_deg= can be computed from the datasheet of the lens.
Then a test calibration should be computed using that value, and the
[[file:mrcal-show-splined-model-correction.html][=mrcal-show-splined-model-correction=]] tool can then be used to validate that
=fov_x_deg= parameter. In the [[file:tour-initial-calibration.org][tour of mrcal]] we get something like this:

#+begin_src sh
mrcal-show-splined-model-correction   \
  --set 'cbrange [0:0.1]'             \
  --unset grid                        \
  --set 'xrange [:] noextend'         \
  --set 'yrange [:] noextend reverse' \
  --set 'key opaque box'              \
  splined.cameramodel
#+end_src

[[file:external/figures/splined-models/splined-magnitude.png]]

This is about what we want. The valid-intrinsics region covers most of the
spline-in-bounds region without going out-of-bounds anywhere. In the [[file:tour-initial-calibration.org][tour of
mrcal]] we followed this procedure to end up with

- =LENSMODEL_SPLINED_STEREOGRAPHIC_order=3_Nx=30_Ny=18_fov_x_deg=150=

Getting this perfect isn't important, so don't spent a ton of time working on
it. See [[file:splined-models.org::#splined models field of view selection][the lensmodel documentation]] for more detail.

** Computing the calibration
:PROPERTIES:
:CUSTOM_ID: calibration
:END:

We're ready. Let's compute the calibration using the [[file:mrcal-calibrate-cameras.html][=mrcal-calibrate-cameras=]]
tool. The invocation should look something like this:

#+begin_src sh
mrcal-calibrate-cameras                                                         \
  --corners-cache corners.vnl                                                   \
  --lensmodel LENSMODEL_SPLINED_STEREOGRAPHIC_order=3_Nx=30_Ny=18_fov_x_deg=150 \
  --focal 1900                                                                  \
  --object-spacing 0.0588                                                       \
  --object-width-n 14                                                           \
  '*.JPG'
#+end_src

- =--corners-cache corners.vnl= says that the chessboard corner coordinates live
  in a file called =corners.vnl=. This is the output of the [[#corner-detector][corner detector]]. If
  this argument is omitted, or a non-existent file is given,
  [[file:mrcal-calibrate-cameras.html][=mrcal-calibrate-cameras=]] will run mrgingham, and write the results into the
  given path. Thus the same command would be used to both compute the corners
  initially, and to reuse the pre-computed corners in subsequent runs.

  As described above, the =corners.vnl= file can come from any chessboard
  detector. If it's a detector that produces a 4th column of /weights/ instead
  of a decimation level, pass in =--corners-cache-has-weights=

- =--lensmodel= specifies which lens model we're using for /all/ the cameras.
  See [[#model-choice][the "Model choice" section above]]. Not being able to select different
  models for different cameras is a current limitation of mrcal. If some very
  different lenses are present in the same calibration, I use a densely-spaced
  (high =Nx=, =Ny=) splined model with the =fov_x_deg= of the widest lens in the
  set. This wastes knots in the too-wide areas of the narrow lenses, but if the
  spline was dense-enough, there're enough knots remaining to fit the narrower
  lenses.

- =--focal 1900= provides the initial estimate for the camera focal lengths, in
  pixels. This doesn't need to be extremely precise, but do try to get this
  close if possible. The focal length value to pass to =--focal=
  ($f_\mathrm{pixels}$) can be derived using the [[file:lensmodels.org::#lensmodel-stereographic][stereographic model]] definition:

\[ f_\mathrm{pixels} \approx \frac{\mathrm{imager\_width\_pixels}}{4 \tan \frac{\mathrm{field\_of\_view\_horizontal}}{4}} \]

  This expression is a good initial estimate for both long and wide lenses. Note
  that the manufacturer-specified "field of view" and "focal length" values are
  usually poorly-defined: the former is different in all directions, and the
  latter is meaningless in wide lenses that are nowhere near the pinhole model.
  With a longer lens, we can assume pinhole behavior to get

\[ f_\mathrm{pixels} = f_\mathrm{mm} \frac{\mathrm{imager\_width\_pixels}}{\mathrm{imager\_width\_mm}} \]

  As with the =fov_x_deg= parameter described in [[#model-choice][the "Model
  choice" section above]], running a test calibration with a rough estimate, and
  then passing in the much-closer optimized value is a good strategy. The
  optimized focal length is the first two values of the =intrinsics= vector in
  the result. Those two values should be similar, and anything around there
  should work well for =--focal=.

- =--object-spacing= is the distance between neighboring corners in the
  chessboard. Even spacing, identical in both directions is assumed

- =--object-width-n= is the horizontal corner count of the calibration object.
  In the example invocation above there is no =--object-height-n=, so
  [[file:mrcal-calibrate-cameras.html][=mrcal-calibrate-cameras=]] assumes a square chessboard

After the options, [[file:mrcal-calibrate-cameras.html][=mrcal-calibrate-cameras=]] takes globs describing the images.
One glob per camera is expected, and in the above example /one/ glob was given:
='*.JPG'=. Thus this is a monocular solve. More cameras would imply more globs.
For instance a 2-camera calibration might take arguments

#+begin_example
'frame*-camera0.png' 'frame*-camera1.png'
#+end_example

Note that these are /globs/, not /filenames/. So they need to be quoted or
escaped to prevent the shell from expanding them: hence ='*.JPG'= and not
=*.JPG=.

Finally, to compute [[#cross-validation][cross-validation diffs (see below)]] it's necessary to run
several independent calibrations. I generally split the dataset into even/odd
chunks, and calibrate them independently. With this =zsh= snippet, for instance:

#+begin_src sh
for oddeven (odd even) {

    cmd=(mrcal-calibrate-cameras                                                       \
         --corners-cache corners.vnl                                                   \
         --lensmodel LENSMODEL_SPLINED_STEREOGRAPHIC_order=3_Nx=30_Ny=18_fov_x_deg=150 \
         --focal 1900                                                                  \
         --object-spacing 0.0588                                                       \
         --object-width-n 14)

    if [[ $oddeven = "even" ]] {
        globs=('frame*[02468]-camera'{0,1}'.png')
    } else {
        globs=('frame*[13579]-camera'{0,1}'.png')
    }

    cmd=($cmd $globs)

    $cmd

    for i (0 1) {
        mv camera-$i.cameramodel camera-$i-$oddeven.cameramodel
    }
}
#+end_src

** Residuals
:PROPERTIES:
:CUSTOM_ID: residuals
:END:

Once we have a calibration, we should evaluate how well it represents reality.

*** Chessboard detector errors
*** Motion blur
*** Rolling shutter
*** Synchronization
*** Lenses not fitting
*** Chessboard shape


--------------

The few worst-fitting images are great at identifying common data-gathering
issues. Zooming in at the worst point (easily identifiable by the color) will
clearly show any motion blur or focus issues. Incorrectly-detected corners will
be visible: they will be outliers or they will have a high error. Especially
with lean models, the errors will be higher towards the edge of the imager: the
lens models fit the worst there.

There should be no discernible pattern to the errors. In a perfect world, the
model fits the observations, and the residuals display purely random noise. Any
patterns in the errors indicate that the noise isn't random, and thus the model
does /not/ fit. This would violate the [[file:formulation.org::#noise-model][noise model]], and would result in a bias
when we ultimately use this calibration for projection. This bias is an
unmodeled source of error, so we /really/ want to push this down as far as we
can. Getting rid of all such errors completely is impossible, but we should do
our best. Out-of-sync camera observations show up as a systematic error vectors
pointing in one direction; and the corresponding out-of-sync image would display
equal and opposite errors. Rolling shutter effects would show a more complex,
but clearly non-random pattern. An insufficiently-rich model of the world (lens
behavior, chessboard shape, etc) results in clear patterns too.



This all might be mentioned directly below
--------------











High outlier counts or high reprojection errors would indicate high model
errors: the model mrcal is using does not fit the data well. That would suggest
some/all of these:

- Issues in the input data, such as incorrectly-detected chessboard corners,
  unsynchronized cameras, rolling shutter, motion blur, focus issues, unstable
  lens, etc.
- A badly-fitting lens model. For instance =LENSMODEL_OPENCV4= will not fit wide
  lenses. And only [[file:splined-models.org][splined lens models]] will fit fisheye lenses all the way to
  the corners
- A badly-fitting chessboard model: is the chessboard flat? If not, does it
  follow the [[file:formulation.org::#board-deformation][deformation model]] well?

Outlier rejection will throw out the worst-fitting data, but these model errors
will still cause an uncorrectable bias in the results. If at all possible, it is
strongly recommended to fix whatever is causing the problem, and then to re-run
the solve.

In this example the [[file:formulation.org::#board-deformation][board deformation]] was computed as 1.0mm horizontally, and
0.5mm vertically in the opposite direction. That is a small deflection, and
sounds reasonable. A way to validate this, would be to get another set of
chessboard images, to rerun the solve, and compare the new flex values to the
old ones. From experience, if things are working properly, these results are
usually consistent.



** Projection uncertainty
:PROPERTIES:
:CUSTOM_ID: uncertainty
:END:





file:recipes.org::#non-mrgingham-detector











HAVE DATA/BOARD HERE. NEED TO GET RID

Finally it's useful to look at the projection uncertainty of the model. As noted
in the [[file:uncertainty.org][documentation]], a rich model is necessary to get realistic uncertainty
estimates, so here we look at the [[file:lensmodels.org::#splined-stereographic-lens-model][=LENSMODEL_SPLINED_STEREOGRAPHIC=]] result from
the [[file:tour.org][tour of mrcal]]:

#+begin_src sh
mrcal-show-projection-uncertainty splined.cameramodel --cbmax 1 --unset key
#+end_src
#+begin_src sh :exports none :eval no-export
D=~/projects/mrcal-doc-external

~/projects/mrcal/mrcal-show-projection-uncertainty \
  $D/data/board/splined.cameramodel \
  --cbmax 1 \
  --unset key \
  --hardcopy ~/projects/mrcal-doc-external/figures/uncertainty/uncertainty-splined.svg \
  --terminal 'svg size 800,600       noenhanced solid dynamic font ",14"'
~/projects/mrcal/mrcal-show-projection-uncertainty \
  $D/data/board/splined.cameramodel \
  --cbmax 1 \
  --unset key \
  --hardcopy ~/projects/mrcal-doc-external/figures/uncertainty/uncertainty-splined.pdf \
  --terminal 'pdf size 8in,6in       noenhanced solid color   font ",12"'
~/projects/mrcal/mrcal-show-projection-uncertainty \
  $D/data/board/splined.cameramodel \
  --cbmax 1 \
  --unset key \
  --hardcopy ~/projects/mrcal-doc-external/figures/uncertainty/uncertainty-splined.png \
  --terminal 'pngcairo size 1024,768 transparent noenhanced crop          font ",12"'
#+end_src

[[file:external/figures/uncertainty/uncertainty-splined.png]]

This is projection uncertainty at infinity. If we care about some other working
distance, this can be requested with =mrcal-show-projection-uncertainty
--distance ...=.

The uncertainties are shown as a color-map along with contours. These are the
expected value of projection errors based on [[file:formulation.org::#noise-model][noise in input corner observations]].
The lowest uncertainties are at roughly the range and imager locations of the
the chessboard observations. Gaps in chessboard coverage will manifest as areas
of high uncertainty.

These uncertainty metrics are complementary to the residual metrics described
above. If we have too little data, the residuals will be low, but the
uncertainties will be very high. The more data we gather, the lower the
uncertainties.

If the residual plots don't show any unexplained errors, then the uncertainty
plots are the authoritative gauge of calibration quality. If the residuals do
suggest problems, then the uncertainty predictions will be overly-optimistic:
the reported uncertainties would not include the extra sources of error.

A good way to validate the reported projection uncertainty is a
cross-validation. Multiple sets of chessboard dance images should be gathered
for the same cameras, and multiple independent calibration solves should be
made. Then a difference can be computed using the [[file:mrcal-show-projection-diff.html][=mrcal-show-projection-diff=
tool]]. This difference should be in line with the uncertainty predictions. If any
unmodeled sources of error are present, the diffs would show high errors despite
low uncertainties.

In the end, if the residuals look reasonable, and the uncertainties look
reasonable then we can use the resulting models, and expect to see the accuracy
predicted by the reported projection uncertainty.

** Cross-validation diffs
:PROPERTIES:
:CUSTOM_ID: cross-validation
:END:



* todo
LOOK UP REFERENCES TO interpreting-results. Should I keep them? Should they
point to anything else?

- hitting the corners

- links to file:lensmodels.org::#splined-stereographic-lens-model should maybe
  point to [[file:splined-models.org]]
