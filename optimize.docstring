Invoke the calibration routine

Synopsis:

    stats = mrcal.optimize( intrinsics_data,
                            extrinsics,
                            frames, points
                            observations_board, indices_frame_camera,
                            observations_point, indices_point_camera_points, 

                            distortion_model, imagersizes,
                            do_optimize_intrinsic_core        = True,
                            do_optimize_intrinsic_distortions = True,
                            calibration_object_spacing        = object_spacing,
                            calibration_object_width_n        = 10,
                            skip_outlier_rejection            = False,
                            skip_regularization               = False,
                            VERBOSE                           = False)

This is a flexible bundle-adjustment implementation, with outlier rejection and
some metrics reported back to the user. More than 2 cameras at a time can be
calibrated, and this routine is flexible-enough to solve SFM problems.

All geometry is given in the coord system of camera 0. As a result, the pose of
camera 0 is hard-coded to the identity, and this isn't a part of the
optimization state.

The input is a combination of observations of a calibration board and
observations of discrete points. The point observations can come JUST from
correspondences, or they can also have a known-distance-to-a-camera (i.e. if
we're looking at very-far-away clouds or known fiducials).

Args:

- intrinsics: array of dims (Ncameras, Nintrinsics). The intrinsics of each
  camera. Each intrinsic vector is given as

    (focal_x, focal_y, center_pixel_x, center_pixel_y, distorion0, distortion1,
    ...)

  The focal lengths are given in pixels.

  On input this is a seed. On output the optimal data is returned. THIS ARRAY IS
  MODIFIED BY THIS CALL.

- extrinsics: array of dims (Ncameras-1, 6). The extrinsics of each camera.
  Camera 0 is the reference coord system, so we omit this from the extrinsics
  array. Each pose is given as 6 values: a rodrigues rotation vector followed by
  a translation. This represents a transformation FROM the reference coord
  system TO the coord system of each camera.

  On input this is a seed. On output the optimal data is returned. THIS ARRAY IS
  MODIFIED BY THIS CALL.

  If we only have one camera, pass either None or np.zeros((0,6))

- frames: array of dims (Nframes, 6). The poses of the calibration object over
  time. Each pose is given as 6 values: a rodrigues rotation vector followed by
  a translation. This represents a transformation FROM the coord system of the
  calibration object TO the reference coord system. THIS IS DIFFERENT FROM THE
  CAMERA EXTRINSICS.

  On input this is a seed. On output the optimal data is returned. THIS ARRAY IS
  MODIFIED BY THIS CALL.

  If we don't have any frames, pass either None or np.zeros((0,6))

- points: array of dims (Npoints, 3). The estimated positions of discrete points
  we're observing. These positions are represented in the reference coord
  system.

  On input this is a seed. On output the optimal data is returned. THIS ARRAY IS
  MODIFIED BY THIS CALL.

- observations_board: array of dims (NobservationsBoard,
                                     calibration_object_width_n,
                                     calibration_object_width_n,
                                     2).
  These are the observed (x,y) pixel coordinates of the dots in the calibration
  object. Subpixel interpolation is assumed, so these contain 64-bit floating
  point values, like all the other data. The frame and camera that produced
  these observations are given in the indices_frame_camera array

- indices_frame_camera_board: array of dims (NobservationsBoard, 2). For each
  observation these are an (i_frame,i_camera) tuple. The frame indices and
  camera indices are guaranteed to be monotonic. This array contains plain 'int'
  integers.

- observations_point: array of dims (NobservationsPoint, 3). These are the
  observed (x,y) pixel coordinates of the point, followed by the reference
  distance. If no reference distance is available, set this to <= 0. Subpixel
  interpolation is assumed, so these contain 64-bit floating point values, like
  all the other data. The point index and camera that produced these
  observations are given in the indices_point_camera_points array.

- indices_point_camera_points: array of dims (NobservationsPoint, 2). For each
  observation these are an (i_point,i_camera) tuple. The point indices and
  camera indices are guaranteed to be monotonic. This array contains plain 'int'
  integers.

- distortion_model: a string such as

  DISTORTION_NONE
  DISTORTION_OPENCV4
  DISTORTION_OPENCV5
  DISTORTION_OPENCV8
  DISTORTION_OPENCV12 (if we have OpenCV >= 3.0.0)
  DISTORTION_OPENCV14 (if we have OpenCV >= 3.1.0)
  DISTORTION_CAHVOR

- imagersizes: integer array of dims (Ncameras,2)

- do_optimize_intrinsic_core
- do_optimize_intrinsic_distortions
- do_optimize_extrinsics
- do_optimize_frames

  optional booleans. Indicate whether to optimize a specific set of variables.
  The intrinsics core is fx,fy,cx,cy. These all default to True so if we specify
  none of these, we will optimize ALL the variables.

- skipped_observations_board: list of integers for the board observations that
  we don't care about. Defaults to None: don't skip anything

- skipped_observations_point: list of integers for the point observations that
  we don't care about. Defaults to None: don't skip anything

- calibration_object_spacing: the width of each square in a calibration
  board. Can be omitted if we have no board observations, just points

- calibration_object_width_n: the calibration board is square, with this many
  points on each side. Can be omitted if we have no board observations, just
  points

- VERBOSE: if True, write out all sorts of diagnostic data to STDERR. Optional;
  defaults to False

- skip_outlier_rejection: if True, don't bother with detecting or rejecting
  outliers. Optional; defaults to False

- skip_regularization: if True, don't include regularization terms in the
  solver. Optional; defaults to False

- solver_context: an object that will receive the context from this solve. This
  is optional. This context can be re-used in other calls, such as
  queryIntrinsicOutliernessAt(). The usage is


      solver_context = mrcal.SolverContext()
      stats = mrcal.optimize( ...,
                              solver_context = solver_context)
      mrcal.queryIntrinsicOutliernessAt( ..., solver_context)

We return a dict with various metrics describing the computation we just
performed
