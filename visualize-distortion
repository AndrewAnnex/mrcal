#!/usr/bin/python2

r'''Renders a vector field to visualize the effect of a model

Synopsis:

  $ visualize-distortion left.cameramodel
  ... a plot pops up showing the vector field

This allows us to visually see what a distortion model does. Depending on the
model, the vectors could be very large or very small, and we can scale them by
passing '--scale s'. By default we sample in a 20x20 grid, but this spacing can
be controlled by passing '--gridn N'.

A tool with similar usefulness is undistort.py. That tool removes the distortion
from a given set of images.

'''


import numpy as np
import numpysane as nps
import gnuplotlib as gp
import sys
import re
import argparse
import os

import mrcal.cahvor
import mrcal



def parse_args():

    parser = \
        argparse.ArgumentParser(description = __doc__,
                                formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument('--gridn',
                        type=int,
                        default = 20,
                        help='''How dense the vector field should be. By default we report a 20x20 grid''')

    parser.add_argument('--scale',
                        type=float,
                        default = 1.0,
                        help='''Scale the vectors by this factor. Default is 1.0 (report the truth), but this is often too small to see''')

    parser.add_argument('--radial',
                        action='store_true',
                        help='''Show the radial distortion scale factor instead''')

    parser.add_argument('--hardcopy',
                        type=str,
                        help='''Write the output to disk, instead of an interactive plot''')

    parser.add_argument('model',
                        type=lambda f: f if os.path.isfile(f) else \
                                parser.error("The cameramodel must be an existing readable file, but got '{}'".format(f)),
                        nargs=1,
                        help='''Input camera model. Assumed to be mrcal native, unless the name is xxx.cahvor,
                        in which case the cahvor format is assumed''')

    return parser.parse_args()



args = parse_args()
if re.match(".*\.cahvor$", args.model[0]):
    model = mrcal.cahvor.read(args.model[0])
else:
    model = mrcal.cameramodel(args.model[0])

# get the input and output grids of shape Nwidth,Nheight,2
W,H = model.imagersize()
intrinsics = model.intrinsics()

plotkwargs = {}
if args.hardcopy is not None:
    plotkwargs['hardcopy'] = args.hardcopy

if not args.radial:
    grid, dgrid = mrcal.distortion_map__to_warped(intrinsics,
                                                  np.linspace(0,W,args.gridn),
                                                  np.linspace(0,H,args.gridn))

    # shape: gridn*gridn,2
    grid  = nps.clump(grid,  n=2)
    dgrid = nps.clump(dgrid, n=2)

    delta = dgrid-grid
    delta *= args.scale

    plotkwargs['_xrange']=(-50,W+50)
    plotkwargs['_yrange']=(H+50, -50)
    plotkwargs['_set'   ]='object 1 rectangle from 0,0 to {},{} fillstyle empty'.format(W,H)
    gp.plot( (grid[:,0], grid[:,1], delta[:,0], delta[:,1],
              {'with': 'vectors size screen 0.005,10 fixed filled',
               'tuplesize': 4,
               }),
             (grid[:,0], grid[:,1],
              {'with': 'points',
               'tuplesize': 2,
               }),
             **plotkwargs )
else:

    # plot the radial distortion. For now I only deal with opencv here
    m = re.search("OPENCV([0-9]+)", intrinsics[0])
    if not m:
        raise Exception("Radial distortion visualization only implemented for OpenCV distortions for now")
    N = int(m.group(1))

    # OpenCV does this:
    #
    # This is the opencv distortion code in cvProjectPoints2 in calibration.cpp
    # Here x,y are x/z and y/z. OpenCV applies distortion to x/z, y/z and THEN
    # does the ...*f + c thing.
    #
    #         r2 = x*x + y*y;
    #         r4 = r2*r2;
    #         r6 = r4*r2;
    #         a1 = 2*x*y;
    #         a2 = r2 + 2*x*x;
    #         a3 = r2 + 2*y*y;
    #         cdist = 1 + k[0]*r2 + k[1]*r4 + k[4]*r6;
    #         icdist2 = 1./(1 + k[5]*r2 + k[6]*r4 + k[7]*r6);
    #         xd0 = x*cdist*icdist2 + k[2]*a1 + k[3]*a2 + k[8]*r2+k[9]*r4;
    #         yd0 = y*cdist*icdist2 + k[2]*a3 + k[3]*a1 + k[10]*r2+k[11]*r4;

    # mean focal length
    f = (intrinsics[1][0] + intrinsics[1][1]) / 2.
    xc = intrinsics[1][2]
    yc = intrinsics[1][3]

    distortions = intrinsics[1][4:]
    k2 = distortions[0]
    k4 = distortions[1]
    k6 = 0
    if N >= 5:
        k6 = distortions[4]
    numerator = '1. + xs*xs * ({} + xs*xs * ({} + xs*xs * {}))'.format(k2,k4,k6)
    numerator = numerator.replace('xs', 'x/{}'.format(f))

    if N >= 8:
        denominator = '1. + xs*xs * ({} + xs*xs * ({} + xs*xs * {}))'.format(*distortions[5:8])
        denominator = denominator.replace('xs', 'x/{}'.format(f))
        scale = '({})/({})'.format(numerator,denominator)
    else:
        scale = numerator


    x01     = np.array((xc, W-xc), dtype=float)
    y01     = np.array((yc, H-yc), dtype=float)
    corners = nps.transpose( nps.glue( nps.cat(x01, y01),
                                       nps.cat(x01, y01[::-1]),
                                       axis=-1))
    corners_len = np.sqrt(nps.norm2(corners))

    equations = ['x * ({}) with lines title "distorted"'.format(scale),
                 'x title "undistorted"']
    sets=['arrow from {xy}, graph 0 to {xy}, graph 1 nohead lc "red"'  .format(xy = x01[0]),
                  'arrow from {xy}, graph 0 to {xy}, graph 1 nohead lc "red"'  .format(xy = x01[1]),
                  'arrow from {xy}, graph 0 to {xy}, graph 1 nohead lc "green"'.format(xy = y01[0]),
                  'arrow from {xy}, graph 0 to {xy}, graph 1 nohead lc "green"'.format(xy = y01[1]),
                  'arrow from {xy}, graph 0 to {xy}, graph 1 nohead lc "blue"' .format(xy = corners_len[0]),
                  'arrow from {xy}, graph 0 to {xy}, graph 1 nohead lc "blue"' .format(xy = corners_len[1]),
                  'arrow from {xy}, graph 0 to {xy}, graph 1 nohead lc "blue"' .format(xy = corners_len[2]),
                  'arrow from {xy}, graph 0 to {xy}, graph 1 nohead lc "blue"' .format(xy = corners_len[3])]
    if N >= 8:
        equations.append(numerator   + ' axis x1y2 title "numerator (y2)"')
        equations.append(denominator + ' axis x1y2 title "denominator (y2)"')
        sets.append('y2tics')
    gp.plot(equation = equations,
            _set=sets,
            _xrange = [0,np.max(corners_len) * 1.05],
            xlabel = 'Pixels from the projection center',
            ylabel = 'Pixels',
            title = 'Radial distortion. Red: x edges. Green: y edges. Blue: corners')

if args.hardcopy is None:
    gp.wait()
