#!/usr/bin/python3

r'''Un-distorts image(s)

SYNOPSIS

  $ mrcal-undistort-image left.cameramodel im1.png im2.png
  ... corresponding pinhole mrcal-native model
  Wrote im1-undistorted.png
  Wrote im2-undistorted.png

Given a single camera model (cahvor or mrcal-native) and some number of images,
this tool un-distorts each image and writes the result to disk. For each image
named xxxx.yyy, the new image filename is xxxx-undistorted.yyy. This tool
refuses to overwrite anything, and will barf if a target file already exists. A
corresponding pinhole camera model is also generated, and written to stdout.

Note that currently the corresponding pinhole model uses the same focal length,
center pixel values as the original, but no distortions. Thus the undistorted
images might cut out chunks of the original, or leave empty borders on the
edges.

The output goes into the same directory as the input image, with a slightly
different filename: image.png -> image-undistorted.png
This tool will refuse to overwrite any existing files unless --force.

'''

from __future__ import print_function

import sys
import argparse
import re
import os

def parse_args():

    parser = \
        argparse.ArgumentParser(description = __doc__,
                                formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument('--fit',
                        type=str,
                        help='''If given, we'll scale the focal length of the pinhole model to fit some of
                        the original image into the output. This is a "zoom"
                        operation. We compute the focal-length scaling based on
                        this argument. If we KNOW the scaling we want, that can
                        be passed-in directly with --scale-focal instead. The
                        argument could be one of ("corners",
                        "centers-horizontal", "centers-vertical"). Or the
                        argument could be given as a list of points
                        x0,y0,x1,y1,x2,y2,.... The focal length scale will be
                        chosen to zoom in as far as possible, while fitting all
                        of these points. If omitted, we keep the focal lengths
                        the same''')

    parser.add_argument('--scale-focal',
                        type=float,
                        help='''If given, we'll scale the focal length of the pinhole model by this factor.
                        This is a "zoom" operation. If we don't know the
                        scaling, but wish to compute it based on fitting some
                        points, use --fit instead''')

    parser.add_argument('--rotate',
                        type=float,
                        nargs=3,
                        help='''If given, the pinhole camera is rotated in respect to the input camera. This
                        is specified as a Rodrigues rotation vector, in degrees:
                        3 numbers. This is a unit vector for the rotation axis
                        scaled by the rotation magnitude. This specifies as the
                        rotation of the CAMERA AROUND ITS OWN AXES. So this is
                        independent of any extrinsics already present in the
                        given cameramodel. Example: to yaw the camera 15
                        degrees, we're rotating around the camera's y axis, so
                        pass "--rotate 0 15 0". If omitted, no rotation is
                        applied''')

    parser.add_argument('--scale-image',
                        type=float,
                        default=1.0,
                        help='''If given, we scale the dimensions of the pinhole image by this factor. By
                        default the scale is 1.0, i.e. the undistorted and
                        distorted images have the same size. This parameter
                        changes the RESOLUTION of the output, unlike
                        --scale-focal, which ZOOMS the output''')

    parser.add_argument('--force', '-f',
                        action='store_true',
                        default=False,
                        help='''By default I don't overwrite existing files. Pass --force to overwrite them
                        without complaint''')

    parser.add_argument('--jobs', '-j',
                        type=int,
                        required=False,
                        default=1,
                        help='''parallelize the processing JOBS-ways. This is like GNU make, except you're
                        required to explicitly specify a job count.''')
    parser.add_argument('model',
                        type=str,
                        help='''Input camera model. Assumed to be mrcal native, Unless the name is xxx.cahvor,
                        in which case the cahvor format is assumed''')
    parser.add_argument('image',
                        type=lambda f: f if os.path.isfile(f) else \
                                parser.error("The images must be readable files, but got '{}'".format(f)),
                        nargs='+',
                        help='''Images to undistort''')

    return parser.parse_args()

args = parse_args()

if args.scale_focal is not None and args.fit is not None:
    sys.stderr.write("Pass either --scale-focal or --fit, but not both\n")
    sys.exit(1)

# arg-parsing is done before the imports so that --help works without building
# stuff, so that I can generate the manpages and README






import numpy as np
import numpysane as nps
import cv2

import multiprocessing
import signal

import mrcal

def target_image_filename(f):
    m = re.match("(.*)\.([a-z][a-z][a-z])$", f, flags=re.I)
    if not m:
        raise Exception("imagefile must end in .xxx where 'xxx' is some image extension. Instead got '{}'".format(f))

    return "{}-undistorted.{}".format(m.group(1),m.group(2))



if not args.force:
    for imagefile in args.image:
        f = target_image_filename(imagefile)
        if os.path.isfile(f):
            sys.stderr.write("Target image '{}' already exists. Doing nothing, and giving up. Pass -f to overwrite.\n".format(f))
            sys.exit(1)

if args.scale_image <= 1e-6:
    sys.stderr.write("--scale-image should be given a reasonable value > 0.\n")
    sys.exit(1)

model = mrcal.cameramodel(args.model)

if args.fit is None:
    if args.scale_focal is None:
        scale_f_pinhole = 1.
    else:
        scale_f_pinhole = float(args.scale_focal)
else:
    if re.match("^\\d+(,\\d+)*$", args.fit):
        xy = np.array([int(x) for x in args.fit.split(',')], dtype=float)
        Nxy = len(xy)
        if Nxy % 2 or Nxy < 4:
            sys.stderr.write(f"If passing pixel coordinates to --fit, I need at least 2 x,y pairs. Instead got {Nxy} values\n")
            sys.exit(1)
        fit = xy.reshape(Nxy//2, 2)
    elif re.match("^(corners|centers-horizontal|centers-vertical)$", args.fit):
        fit = args.fit
    else:
        sys.stderr.write("--fit must be a comma-separated list of integers or one of ('corners','centers-horizontal','centers-vertical')\n")
        sys.exit(1)

    scale_f_pinhole = \
        mrcal.compute_scale_f_pinhole_for_fit(model, fit,
                                              scale_imagersize_pinhole = args.scale_image)
    sys.stderr.write(f"scale_f_pinhole = {scale_f_pinhole}\n")

mapxy, model_pinhole = \
    mrcal.undistort_image__compute_map(model,
                                       scale_f_pinhole           = scale_f_pinhole,
                                       scale_imagersize_pinhole  = args.scale_image,
                                       R_pinhole_input           = mrcal.R_from_r(-np.array(args.rotate) * np.pi/180.) \
                                         if args.rotate is not None else None)

print("# Corresponding pinhole model:")
model_pinhole.write(sys.stdout)



def undistort_this(imagefile):
    imagefile_undistorted = target_image_filename(imagefile)

    image_undistorted = mrcal.undistort_image(model, imagefile,
                                              mapxy = mapxy)
    cv2.imwrite(imagefile_undistorted, image_undistorted)
    sys.stderr.write("Wrote {}\n".format(imagefile_undistorted))


# weird business to handle weird signal handling in multiprocessing. I want
# things like the user hitting C-c to work properly. So I ignore SIGINT for the
# children. And I want the parent's blocking wait for results to respond to
# signals. Which means map_async() instead of map(), and wait(big number)
# instead of wait()
signal_handler_sigint = signal.signal(signal.SIGINT, signal.SIG_IGN)
pool = multiprocessing.Pool(args.jobs)
signal.signal(signal.SIGINT, signal_handler_sigint)
try:
    mapresult = pool.map_async(undistort_this, args.image)

    # like wait(), but will barf if something goes wrong. I don't actually care
    # about the results
    mapresult.get(1000000)
except:
    pool.terminate()

pool.close()
pool.join()
