#!/usr/bin/python3

r'''Un-distorts image(s)

SYNOPSIS

  $ mrcal-undistort-image --model left.cameramodel im1.png im2.png
  ... corresponding pinhole mrcal-native model
  Wrote im1-undistorted.png
  Wrote im2-undistorted.png

Given a single camera model (cahvor or mrcal-native) and some number of images,
this tool un-distorts each image and writes the result to disk. For each image
named xxxx.yyy, the new image filename is xxxx-undistorted.yyy. This tool
refuses to overwrite anything, and will barf if a target file already exists. A
corresponding pinhole camera model is also generated, and written to stdout.

Note that currently the corresponding pinhole model uses the same focal length,
center pixel values as the original, but no distortions. Thus the undistorted
images might cut out chunks of the original, or leave empty borders on the
edges.

'''

from __future__ import print_function

import sys
import argparse
import re
import os

def parse_args():

    parser = \
        argparse.ArgumentParser(description = __doc__,
                                formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('--model',
                        type=lambda f: f if os.path.isfile(f) else \
                                parser.error("The cameramodel must be an existing readable file, but got '{}'".format(f)),
                        required=True,
                        help='''Input camera model. Assumed to be mrcal native, Unless the name is xxx.cahvor,
                        in which case the cahvor format is assumed''')

    parser.add_argument('--fit',
                        type=str,
                        required=False,
                        help='''If given, we'll scale the focal length of the pinhole model to fit some of
                        the original image into the output. This is one of
                        "corners", "centers-horizontal", "centers-vertical". If
                        omitted, we keep the focal lengths the same''')

    parser.add_argument('--scale',
                        type=float,
                        default=1.0,
                        help='''If given, we scale the size of the pinhole image by this factor. By default
                        the scale is 1.0, i.e. the undistorted and distorted
                        images have the same size''')

    parser.add_argument('--force', '-f',
                        action='store_true',
                        default=False,
                        help='''By default I don't overwrite existing files. Pass --force to overwrite them
                        without complaint''')

    parser.add_argument('--jobs', '-j',
                        type=int,
                        required=False,
                        default=1,
                        help='''parallelize the processing JOBS-ways. This is like GNU make, except you're
                        required to explicitly specify a job count.''')

    parser.add_argument('image',
                        type=lambda f: f if os.path.isfile(f) else \
                                parser.error("The images must be readable files, but got '{}'".format(f)),
                        nargs='+',
                        help='''Images to undistort''')

    return parser.parse_args()

args = parse_args()

# arg-parsing is done before the imports so that --help works without building
# stuff, so that I can generate the manpages and README






import numpy as np
import numpysane as nps
import cv2

import multiprocessing
import signal

import mrcal

def target_image_filename(f):
    m = re.match("(.*)\.([a-z][a-z][a-z])$", f, flags=re.I)
    if not m:
        raise Exception("imagefile must end in .xxx where 'xxx' is some image extension. Instead got '{}'".format(f))

    return "{}-undistorted.{}".format(m.group(1),m.group(2))



if not args.force:
    for imagefile in args.image:
        f = target_image_filename(imagefile)
        if os.path.isfile(f):
            sys.stderr.write("Target image '{}' already exists. Doing nothing, and giving up. Pass -f to overwrite.\n".format(f))
            sys.exit(1)

model = mrcal.cameramodel(args.model)

if args.fit is None:
    scale_f_pinhole = 1.0
elif re.match("^(corners|centers-horizontal|centers-vertical)$", args.fit):
    scale_f_pinhole =  mrcal.compute_scale_f_pinhole_for_fit(model, args.fit,
                                                             scale_imagersize_pinhole = args.scale)
else:
    sys.stderr.write("--fit must be one of ('corners','centers-horizontal','centers-vertical')\n")
    sys.exit(1)

if args.scale <= 1e-6:
    sys.stderr.write("--scale should be given a reasonable value > 0.\n")
    sys.exit(1)

mapxy, intrinsics_pinhole, imagersize_pinhole = \
    mrcal.undistort_image__compute_map(model,
                                       scale_f_pinhole               = scale_f_pinhole,
                                       scale_imagersize_pinhole      = args.scale,
                                       report_new_pinhole_parameters = True)

model_pinhole = mrcal.cameramodel( model )
model_pinhole.intrinsics(imagersize_pinhole,
                         ('DISTORTION_NONE', intrinsics_pinhole))

print("Corresponding pinhole model (cameramodel):")
print("")
print("=====================================")
model_pinhole.write(sys.stdout)
print("=====================================")
print("")

print("Corresponding pinhole model (cahvor):")
print("")
print("=====================================")
model_pinhole.write(sys.stdout, cahvor=True)
print("=====================================")
print("")


def undistort_this(imagefile):
    imagefile_undistorted = target_image_filename(imagefile)

    image_undistorted = mrcal.undistort_image(model, imagefile,
                                              mapxy = mapxy)
    cv2.imwrite(imagefile_undistorted, image_undistorted)
    sys.stderr.write("Wrote {}\n".format(imagefile_undistorted))


# weird business to handle weird signal handling in multiprocessing. I want
# things like the user hitting C-c to work properly. So I ignore SIGINT for the
# children. And I want the parent's blocking wait for results to respond to
# signals. Which means map_async() instead of map(), and wait(big number)
# instead of wait()
signal_handler_sigint = signal.signal(signal.SIGINT, signal.SIG_IGN)
pool = multiprocessing.Pool(args.jobs)
signal.signal(signal.SIGINT, signal_handler_sigint)
try:
    mapresult = pool.map_async(undistort_this, args.image)

    # like wait(), but will barf if something goes wrong. I don't actually care
    # about the results
    mapresult.get(1000000)
except:
    pool.terminate()

pool.close()
pool.join()
